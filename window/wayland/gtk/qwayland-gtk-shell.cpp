// This file was generated by qtwaylandscanner
// source file is gtk-shell.xml

#include <wayland-client-protocol.h>

#include "qwayland-gtk-shell.h"

QT_BEGIN_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")

namespace QtWayland {

#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR >= 20) || WAYLAND_VERSION_MAJOR > 1
static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
{
    const uint32_t bindOpCode = 0;
#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
        bindOpCode, interface, version, name, interface->name, version, nullptr);
#else
    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
        bindOpCode, interface, name, interface->name, version, nullptr);
#endif
}
#endif

    gtk_shell1::gtk_shell1(struct ::wl_registry *registry, int id, int version)
    {
        init(registry, id, version);
    }

    gtk_shell1::gtk_shell1(struct ::gtk_shell1 *obj)
        : m_gtk_shell1(obj)
    {
        init_listener();
    }

    gtk_shell1::gtk_shell1()
        : m_gtk_shell1(nullptr)
    {
    }

    gtk_shell1::~gtk_shell1()
    {
    }

    void gtk_shell1::init(struct ::wl_registry *registry, int id, int version)
    {
#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR >= 20) || WAYLAND_VERSION_MAJOR > 1
        m_gtk_shell1 = static_cast<struct ::gtk_shell1 *>(wlRegistryBind(registry, id, &gtk_shell1_interface, version));
#else
        m_gtk_shell1 = static_cast<struct ::gtk_shell1 *>(::wl_registry_bind(registry, id, &gtk_shell1_interface, version));
#endif
        init_listener();
    }

    void gtk_shell1::init(struct ::gtk_shell1 *obj)
    {
        m_gtk_shell1 = obj;
        init_listener();
    }

    gtk_shell1 *gtk_shell1::fromObject(struct ::gtk_shell1 *object)
    {
        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_gtk_shell1_listener)
            return nullptr;
        return static_cast<gtk_shell1 *>(gtk_shell1_get_user_data(object));
    }

    bool gtk_shell1::isInitialized() const
    {
        return m_gtk_shell1 != nullptr;
    }

    const struct wl_interface *gtk_shell1::interface()
    {
        return &::gtk_shell1_interface;
    }

    void gtk_shell1::destroy()
    {
        ::gtk_shell1_destroy(
            m_gtk_shell1);
        m_gtk_shell1 = nullptr;
    }

    struct ::gtk_surface1 *gtk_shell1::get_gtk_surface(struct ::wl_surface *surface)
    {
        return gtk_shell1_get_gtk_surface(
            m_gtk_shell1,
            surface);
    }

    void gtk_shell1::set_startup_id(const QString &startup_id)
    {
        gtk_shell1_set_startup_id(
            m_gtk_shell1,
            startup_id.toUtf8().constData());
    }

    void gtk_shell1::system_bell(struct ::gtk_surface1 *surface)
    {
        gtk_shell1_system_bell(
            m_gtk_shell1,
            surface);
    }

    void gtk_shell1::notify_launch(const QString &startup_id)
    {
        gtk_shell1_notify_launch(
            m_gtk_shell1,
            startup_id.toUtf8().constData());
    }

    void gtk_shell1::gtk_shell1_capabilities(uint32_t )
    {
    }

    void gtk_shell1::handle_capabilities(
        void *data,
        struct ::gtk_shell1 *object,
        uint32_t capabilities)
    {
        Q_UNUSED(object);
        static_cast<gtk_shell1 *>(data)->gtk_shell1_capabilities(
            capabilities);
    }

    const struct gtk_shell1_listener gtk_shell1::m_gtk_shell1_listener = {
        gtk_shell1::handle_capabilities,
    };

    void gtk_shell1::init_listener()
    {
        gtk_shell1_add_listener(m_gtk_shell1, &m_gtk_shell1_listener, this);
    }

    gtk_surface1::gtk_surface1(struct ::wl_registry *registry, int id, int version)
    {
        init(registry, id, version);
    }

    gtk_surface1::gtk_surface1(struct ::gtk_surface1 *obj)
        : m_gtk_surface1(obj)
    {
        init_listener();
    }

    gtk_surface1::gtk_surface1()
        : m_gtk_surface1(nullptr)
    {
    }

    gtk_surface1::~gtk_surface1()
    {
    }

    void gtk_surface1::init(struct ::wl_registry *registry, int id, int version)
    {
#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR >= 20) || WAYLAND_VERSION_MAJOR > 1
        m_gtk_surface1 = static_cast<struct ::gtk_surface1 *>(wlRegistryBind(registry, id, &gtk_surface1_interface, version));
#else
        m_gtk_surface1 = static_cast<struct ::gtk_surface1 *>(::wl_registry_bind(registry, id, &gtk_surface1_interface, version));
#endif
        init_listener();
    }

    void gtk_surface1::init(struct ::gtk_surface1 *obj)
    {
        m_gtk_surface1 = obj;
        init_listener();
    }

    gtk_surface1 *gtk_surface1::fromObject(struct ::gtk_surface1 *object)
    {
        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_gtk_surface1_listener)
            return nullptr;
        return static_cast<gtk_surface1 *>(gtk_surface1_get_user_data(object));
    }

    bool gtk_surface1::isInitialized() const
    {
        return m_gtk_surface1 != nullptr;
    }

    const struct wl_interface *gtk_surface1::interface()
    {
        return &::gtk_surface1_interface;
    }

    void gtk_surface1::set_dbus_properties(const QString &application_id, const QString &app_menu_path, const QString &menubar_path, const QString &window_object_path, const QString &application_object_path, const QString &unique_bus_name)
    {
        gtk_surface1_set_dbus_properties(
            m_gtk_surface1,
            application_id.toUtf8().constData(),
            app_menu_path.toUtf8().constData(),
            menubar_path.toUtf8().constData(),
            window_object_path.toUtf8().constData(),
            application_object_path.toUtf8().constData(),
            unique_bus_name.toUtf8().constData());
    }

    void gtk_surface1::set_modal()
    {
        gtk_surface1_set_modal(
            m_gtk_surface1);
    }

    void gtk_surface1::unset_modal()
    {
        gtk_surface1_unset_modal(
            m_gtk_surface1);
    }

    void gtk_surface1::present(uint32_t time)
    {
        gtk_surface1_present(
            m_gtk_surface1,
            time);
    }

    void gtk_surface1::request_focus(const QString &startup_id)
    {
        gtk_surface1_request_focus(
            m_gtk_surface1,
            startup_id.toUtf8().constData());
    }

    void gtk_surface1::release()
    {
        gtk_surface1_release(
            m_gtk_surface1);
        m_gtk_surface1 = nullptr;
    }

    void gtk_surface1::gtk_surface1_configure(wl_array *)
    {
    }

    void gtk_surface1::handle_configure(
        void *data,
        struct ::gtk_surface1 *object,
        wl_array *states)
    {
        Q_UNUSED(object);
        static_cast<gtk_surface1 *>(data)->gtk_surface1_configure(
            states);
    }

    void gtk_surface1::gtk_surface1_configure_edges(wl_array *)
    {
    }

    void gtk_surface1::handle_configure_edges(
        void *data,
        struct ::gtk_surface1 *object,
        wl_array *constraints)
    {
        Q_UNUSED(object);
        static_cast<gtk_surface1 *>(data)->gtk_surface1_configure_edges(
            constraints);
    }

    const struct gtk_surface1_listener gtk_surface1::m_gtk_surface1_listener = {
        gtk_surface1::handle_configure,
        gtk_surface1::handle_configure_edges,
    };

    void gtk_surface1::init_listener()
    {
        gtk_surface1_add_listener(m_gtk_surface1, &m_gtk_surface1_listener, this);
    }
}

QT_WARNING_POP
QT_END_NAMESPACE
