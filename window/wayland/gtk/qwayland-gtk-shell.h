// This file was generated by qtwaylandscanner
// source file is gtk-shell.xml

#ifndef QT_WAYLAND_GTK
#define QT_WAYLAND_GTK

#include "wayland-gtk-shell-client-protocol.h"
#include <QByteArray>
#include <QString>

struct wl_registry;

QT_BEGIN_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")

namespace QtWayland {
    class  gtk_shell1
    {
    public:
        gtk_shell1(struct ::wl_registry *registry, int id, int version);
        gtk_shell1(struct ::gtk_shell1 *object);
        gtk_shell1();

        virtual ~gtk_shell1();

        void init(struct ::wl_registry *registry, int id, int version);
        void init(struct ::gtk_shell1 *object);

        struct ::gtk_shell1 *object() { return m_gtk_shell1; }
        const struct ::gtk_shell1 *object() const { return m_gtk_shell1; }
        static gtk_shell1 *fromObject(struct ::gtk_shell1 *object);

        bool isInitialized() const;

        static const struct ::wl_interface *interface();

        void destroy();

        enum capability {
            capability_global_app_menu = 1,
            capability_global_menu_bar = 2,
            capability_desktop_icons = 3,
        };

        struct ::gtk_surface1 *get_gtk_surface(struct ::wl_surface *surface);
        void set_startup_id(const QString &startup_id);
        void system_bell(struct ::gtk_surface1 *surface);
        void notify_launch(const QString &startup_id);

    protected:
        virtual void gtk_shell1_capabilities(uint32_t capabilities);

    private:
        void init_listener();
        static const struct gtk_shell1_listener m_gtk_shell1_listener;
        static void handle_capabilities(
            void *data,
            struct ::gtk_shell1 *object,
            uint32_t capabilities);
        struct ::gtk_shell1 *m_gtk_shell1;
    };

    class  gtk_surface1
    {
    public:
        gtk_surface1(struct ::wl_registry *registry, int id, int version);
        gtk_surface1(struct ::gtk_surface1 *object);
        gtk_surface1();

        virtual ~gtk_surface1();

        void init(struct ::wl_registry *registry, int id, int version);
        void init(struct ::gtk_surface1 *object);

        struct ::gtk_surface1 *object() { return m_gtk_surface1; }
        const struct ::gtk_surface1 *object() const { return m_gtk_surface1; }
        static gtk_surface1 *fromObject(struct ::gtk_surface1 *object);

        bool isInitialized() const;

        static const struct ::wl_interface *interface();

        enum state {
            state_tiled = 1,
            state_tiled_top = 2,
            state_tiled_right = 3,
            state_tiled_bottom = 4,
            state_tiled_left = 5,
        };

        enum edge_constraint {
            edge_constraint_resizable_top = 1,
            edge_constraint_resizable_right = 2,
            edge_constraint_resizable_bottom = 3,
            edge_constraint_resizable_left = 4,
        };

        void set_dbus_properties(const QString &application_id, const QString &app_menu_path, const QString &menubar_path, const QString &window_object_path, const QString &application_object_path, const QString &unique_bus_name);
        void set_modal();
        void unset_modal();
        void present(uint32_t time);
        void request_focus(const QString &startup_id);
        void release();

    protected:
        virtual void gtk_surface1_configure(wl_array *states);
        virtual void gtk_surface1_configure_edges(wl_array *constraints);

    private:
        void init_listener();
        static const struct gtk_surface1_listener m_gtk_surface1_listener;
        static void handle_configure(
            void *data,
            struct ::gtk_surface1 *object,
            wl_array *states);
        static void handle_configure_edges(
            void *data,
            struct ::gtk_surface1 *object,
            wl_array *constraints);
        struct ::gtk_surface1 *m_gtk_surface1;
    };
}

QT_WARNING_POP
QT_END_NAMESPACE

#endif
