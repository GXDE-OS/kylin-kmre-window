// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KmreCore.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_KmreCore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_KmreCore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_KmreCore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_KmreCore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_KmreCore_2eproto;
namespace cn {
namespace kylinos {
namespace kmre {
namespace kmrecore {
class ActionResult;
struct ActionResultDefaultTypeInternal;
extern ActionResultDefaultTypeInternal _ActionResult_default_instance_;
class AnswerCall;
struct AnswerCallDefaultTypeInternal;
extern AnswerCallDefaultTypeInternal _AnswerCall_default_instance_;
class AppMultiplier;
struct AppMultiplierDefaultTypeInternal;
extern AppMultiplierDefaultTypeInternal _AppMultiplier_default_instance_;
class AppMultiplierList;
struct AppMultiplierListDefaultTypeInternal;
extern AppMultiplierListDefaultTypeInternal _AppMultiplierList_default_instance_;
class CloseApp;
struct CloseAppDefaultTypeInternal;
extern CloseAppDefaultTypeInternal _CloseApp_default_instance_;
class CloseResult;
struct CloseResultDefaultTypeInternal;
extern CloseResultDefaultTypeInternal _CloseResult_default_instance_;
class ContainerEnvBootStatus;
struct ContainerEnvBootStatusDefaultTypeInternal;
extern ContainerEnvBootStatusDefaultTypeInternal _ContainerEnvBootStatus_default_instance_;
class ControlApp;
struct ControlAppDefaultTypeInternal;
extern ControlAppDefaultTypeInternal _ControlApp_default_instance_;
class DragFile;
struct DragFileDefaultTypeInternal;
extern DragFileDefaultTypeInternal _DragFile_default_instance_;
class EventInfo;
struct EventInfoDefaultTypeInternal;
extern EventInfoDefaultTypeInternal _EventInfo_default_instance_;
class EventSequence;
struct EventSequenceDefaultTypeInternal;
extern EventSequenceDefaultTypeInternal _EventSequence_default_instance_;
class FilesList;
struct FilesListDefaultTypeInternal;
extern FilesListDefaultTypeInternal _FilesList_default_instance_;
class FocusWin;
struct FocusWinDefaultTypeInternal;
extern FocusWinDefaultTypeInternal _FocusWin_default_instance_;
class GetInfoList;
struct GetInfoListDefaultTypeInternal;
extern GetInfoListDefaultTypeInternal _GetInfoList_default_instance_;
class GetInstalledAppList;
struct GetInstalledAppListDefaultTypeInternal;
extern GetInstalledAppListDefaultTypeInternal _GetInstalledAppList_default_instance_;
class GetRunningAppList;
struct GetRunningAppListDefaultTypeInternal;
extern GetRunningAppListDefaultTypeInternal _GetRunningAppList_default_instance_;
class GetSystemProp;
struct GetSystemPropDefaultTypeInternal;
extern GetSystemPropDefaultTypeInternal _GetSystemProp_default_instance_;
class Info;
struct InfoDefaultTypeInternal;
extern InfoDefaultTypeInternal _Info_default_instance_;
class InputMethodRequest;
struct InputMethodRequestDefaultTypeInternal;
extern InputMethodRequestDefaultTypeInternal _InputMethodRequest_default_instance_;
class InsertFile;
struct InsertFileDefaultTypeInternal;
extern InsertFileDefaultTypeInternal _InsertFile_default_instance_;
class InstallApp;
struct InstallAppDefaultTypeInternal;
extern InstallAppDefaultTypeInternal _InstallApp_default_instance_;
class InstalledAppItem;
struct InstalledAppItemDefaultTypeInternal;
extern InstalledAppItemDefaultTypeInternal _InstalledAppItem_default_instance_;
class InstalledAppList;
struct InstalledAppListDefaultTypeInternal;
extern InstalledAppListDefaultTypeInternal _InstalledAppList_default_instance_;
class LaunchApp;
struct LaunchAppDefaultTypeInternal;
extern LaunchAppDefaultTypeInternal _LaunchApp_default_instance_;
class LaunchResult;
struct LaunchResultDefaultTypeInternal;
extern LaunchResultDefaultTypeInternal _LaunchResult_default_instance_;
class LinkOpen;
struct LinkOpenDefaultTypeInternal;
extern LinkOpenDefaultTypeInternal _LinkOpen_default_instance_;
class MediaPlayStatus;
struct MediaPlayStatusDefaultTypeInternal;
extern MediaPlayStatusDefaultTypeInternal _MediaPlayStatus_default_instance_;
class MultiplierSwitch;
struct MultiplierSwitchDefaultTypeInternal;
extern MultiplierSwitchDefaultTypeInternal _MultiplierSwitch_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class RemoveFile;
struct RemoveFileDefaultTypeInternal;
extern RemoveFileDefaultTypeInternal _RemoveFile_default_instance_;
class RequestMediaFiles;
struct RequestMediaFilesDefaultTypeInternal;
extern RequestMediaFilesDefaultTypeInternal _RequestMediaFiles_default_instance_;
class ResponseInfo;
struct ResponseInfoDefaultTypeInternal;
extern ResponseInfoDefaultTypeInternal _ResponseInfo_default_instance_;
class RotationChanged;
struct RotationChangedDefaultTypeInternal;
extern RotationChangedDefaultTypeInternal _RotationChanged_default_instance_;
class RunningAppItem;
struct RunningAppItemDefaultTypeInternal;
extern RunningAppItemDefaultTypeInternal _RunningAppItem_default_instance_;
class RunningAppList;
struct RunningAppListDefaultTypeInternal;
extern RunningAppListDefaultTypeInternal _RunningAppList_default_instance_;
class SendSystemProp;
struct SendSystemPropDefaultTypeInternal;
extern SendSystemPropDefaultTypeInternal _SendSystemProp_default_instance_;
class SetClipboard;
struct SetClipboardDefaultTypeInternal;
extern SetClipboardDefaultTypeInternal _SetClipboard_default_instance_;
class SetProxy;
struct SetProxyDefaultTypeInternal;
extern SetProxyDefaultTypeInternal _SetProxy_default_instance_;
class SetSystemProp;
struct SetSystemPropDefaultTypeInternal;
extern SetSystemPropDefaultTypeInternal _SetSystemProp_default_instance_;
class SingleFile;
struct SingleFileDefaultTypeInternal;
extern SingleFileDefaultTypeInternal _SingleFile_default_instance_;
class UninstallApp;
struct UninstallAppDefaultTypeInternal;
extern UninstallAppDefaultTypeInternal _UninstallApp_default_instance_;
class UpdateAppWindowSize;
struct UpdateAppWindowSizeDefaultTypeInternal;
extern UpdateAppWindowSizeDefaultTypeInternal _UpdateAppWindowSize_default_instance_;
class UpdateDisplaySize;
struct UpdateDisplaySizeDefaultTypeInternal;
extern UpdateDisplaySizeDefaultTypeInternal _UpdateDisplaySize_default_instance_;
class UpdatePackageStatus;
struct UpdatePackageStatusDefaultTypeInternal;
extern UpdatePackageStatusDefaultTypeInternal _UpdatePackageStatus_default_instance_;
class VirtualScreenFocusResult;
struct VirtualScreenFocusResultDefaultTypeInternal;
extern VirtualScreenFocusResultDefaultTypeInternal _VirtualScreenFocusResult_default_instance_;
}  // namespace kmrecore
}  // namespace kmre
}  // namespace kylinos
}  // namespace cn
PROTOBUF_NAMESPACE_OPEN
template<> ::cn::kylinos::kmre::kmrecore::ActionResult* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::ActionResult>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::AnswerCall* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::AnswerCall>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::AppMultiplier* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::AppMultiplier>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::AppMultiplierList* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::AppMultiplierList>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::CloseApp* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::CloseApp>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::CloseResult* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::CloseResult>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::ControlApp* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::ControlApp>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::DragFile* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::DragFile>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::EventInfo* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::EventInfo>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::EventSequence* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::EventSequence>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::FilesList* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::FilesList>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::FocusWin* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::FocusWin>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::GetInfoList* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::GetInfoList>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::GetInstalledAppList* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::GetInstalledAppList>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::GetRunningAppList* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::GetRunningAppList>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::GetSystemProp* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::GetSystemProp>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::Info* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::Info>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::InputMethodRequest* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::InputMethodRequest>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::InsertFile* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::InsertFile>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::InstallApp* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::InstallApp>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::InstalledAppItem* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::InstalledAppItem>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::InstalledAppList* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::InstalledAppList>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::LaunchApp* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::LaunchApp>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::LaunchResult* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::LaunchResult>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::LinkOpen* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::LinkOpen>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::MediaPlayStatus>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::MultiplierSwitch>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::Notification* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::Notification>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::RemoveFile* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::RemoveFile>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::RequestMediaFiles* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::RequestMediaFiles>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::ResponseInfo* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::ResponseInfo>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::RotationChanged* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::RotationChanged>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::RunningAppItem* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::RunningAppItem>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::RunningAppList* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::RunningAppList>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::SendSystemProp* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::SendSystemProp>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::SetClipboard* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::SetClipboard>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::SetProxy* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::SetProxy>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::SetSystemProp* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::SetSystemProp>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::SingleFile* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::SingleFile>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::UninstallApp* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::UninstallApp>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::UpdateAppWindowSize* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::UpdateAppWindowSize>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::UpdateDisplaySize* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::UpdateDisplaySize>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::UpdatePackageStatus>(Arena*);
template<> ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* Arena::CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cn {
namespace kylinos {
namespace kmre {
namespace kmrecore {

// ===================================================================

class InstallApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.InstallApp) */ {
 public:
  inline InstallApp() : InstallApp(nullptr) {}
  ~InstallApp() override;
  explicit PROTOBUF_CONSTEXPR InstallApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallApp(const InstallApp& from);
  InstallApp(InstallApp&& from) noexcept
    : InstallApp() {
    *this = ::std::move(from);
  }

  inline InstallApp& operator=(const InstallApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallApp& operator=(InstallApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallApp* internal_default_instance() {
    return reinterpret_cast<const InstallApp*>(
               &_InstallApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InstallApp& a, InstallApp& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstallApp& from) {
    InstallApp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.InstallApp";
  }
  protected:
  explicit InstallApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kAppNameFieldNumber = 2,
    kPackageNameFieldNumber = 3,
  };
  // required string file_name = 1;
  bool has_file_name() const;
  private:
  bool _internal_has_file_name() const;
  public:
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // required string app_name = 2;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // required string package_name = 3;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.InstallApp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class UninstallApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.UninstallApp) */ {
 public:
  inline UninstallApp() : UninstallApp(nullptr) {}
  ~UninstallApp() override;
  explicit PROTOBUF_CONSTEXPR UninstallApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UninstallApp(const UninstallApp& from);
  UninstallApp(UninstallApp&& from) noexcept
    : UninstallApp() {
    *this = ::std::move(from);
  }

  inline UninstallApp& operator=(const UninstallApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline UninstallApp& operator=(UninstallApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UninstallApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const UninstallApp* internal_default_instance() {
    return reinterpret_cast<const UninstallApp*>(
               &_UninstallApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UninstallApp& a, UninstallApp& b) {
    a.Swap(&b);
  }
  inline void Swap(UninstallApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UninstallApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UninstallApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UninstallApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UninstallApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UninstallApp& from) {
    UninstallApp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UninstallApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.UninstallApp";
  }
  protected:
  explicit UninstallApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
  };
  // required string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.UninstallApp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class LaunchApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.LaunchApp) */ {
 public:
  inline LaunchApp() : LaunchApp(nullptr) {}
  ~LaunchApp() override;
  explicit PROTOBUF_CONSTEXPR LaunchApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaunchApp(const LaunchApp& from);
  LaunchApp(LaunchApp&& from) noexcept
    : LaunchApp() {
    *this = ::std::move(from);
  }

  inline LaunchApp& operator=(const LaunchApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaunchApp& operator=(LaunchApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaunchApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaunchApp* internal_default_instance() {
    return reinterpret_cast<const LaunchApp*>(
               &_LaunchApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LaunchApp& a, LaunchApp& b) {
    a.Swap(&b);
  }
  inline void Swap(LaunchApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaunchApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaunchApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaunchApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaunchApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaunchApp& from) {
    LaunchApp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaunchApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.LaunchApp";
  }
  protected:
  explicit LaunchApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kFullscreenFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kDensityFieldNumber = 5,
  };
  // required string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required bool fullscreen = 2;
  bool has_fullscreen() const;
  private:
  bool _internal_has_fullscreen() const;
  public:
  void clear_fullscreen();
  bool fullscreen() const;
  void set_fullscreen(bool value);
  private:
  bool _internal_fullscreen() const;
  void _internal_set_fullscreen(bool value);
  public:

  // required int32 width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // required int32 height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // required int32 density = 5;
  bool has_density() const;
  private:
  bool _internal_has_density() const;
  public:
  void clear_density();
  int32_t density() const;
  void set_density(int32_t value);
  private:
  int32_t _internal_density() const;
  void _internal_set_density(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.LaunchApp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    bool fullscreen_;
    int32_t width_;
    int32_t height_;
    int32_t density_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class CloseApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.CloseApp) */ {
 public:
  inline CloseApp() : CloseApp(nullptr) {}
  ~CloseApp() override;
  explicit PROTOBUF_CONSTEXPR CloseApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseApp(const CloseApp& from);
  CloseApp(CloseApp&& from) noexcept
    : CloseApp() {
    *this = ::std::move(from);
  }

  inline CloseApp& operator=(const CloseApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseApp& operator=(CloseApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseApp* internal_default_instance() {
    return reinterpret_cast<const CloseApp*>(
               &_CloseApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CloseApp& a, CloseApp& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloseApp& from) {
    CloseApp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.CloseApp";
  }
  protected:
  explicit CloseApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 1,
    kPackageNameFieldNumber = 2,
    kForceKillFieldNumber = 3,
  };
  // required string app_name = 1;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // optional bool force_kill = 3;
  bool has_force_kill() const;
  private:
  bool _internal_has_force_kill() const;
  public:
  void clear_force_kill();
  bool force_kill() const;
  void set_force_kill(bool value);
  private:
  bool _internal_force_kill() const;
  void _internal_set_force_kill(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.CloseApp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    bool force_kill_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class GetInstalledAppList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.GetInstalledAppList) */ {
 public:
  inline GetInstalledAppList() : GetInstalledAppList(nullptr) {}
  ~GetInstalledAppList() override;
  explicit PROTOBUF_CONSTEXPR GetInstalledAppList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInstalledAppList(const GetInstalledAppList& from);
  GetInstalledAppList(GetInstalledAppList&& from) noexcept
    : GetInstalledAppList() {
    *this = ::std::move(from);
  }

  inline GetInstalledAppList& operator=(const GetInstalledAppList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInstalledAppList& operator=(GetInstalledAppList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInstalledAppList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInstalledAppList* internal_default_instance() {
    return reinterpret_cast<const GetInstalledAppList*>(
               &_GetInstalledAppList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetInstalledAppList& a, GetInstalledAppList& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInstalledAppList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInstalledAppList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInstalledAppList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInstalledAppList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInstalledAppList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInstalledAppList& from) {
    GetInstalledAppList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInstalledAppList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.GetInstalledAppList";
  }
  protected:
  explicit GetInstalledAppList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeHideAppFieldNumber = 1,
  };
  // optional bool include_hide_app = 1;
  bool has_include_hide_app() const;
  private:
  bool _internal_has_include_hide_app() const;
  public:
  void clear_include_hide_app();
  bool include_hide_app() const;
  void set_include_hide_app(bool value);
  private:
  bool _internal_include_hide_app() const;
  void _internal_set_include_hide_app(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.GetInstalledAppList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool include_hide_app_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class GetRunningAppList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.GetRunningAppList) */ {
 public:
  inline GetRunningAppList() : GetRunningAppList(nullptr) {}
  ~GetRunningAppList() override;
  explicit PROTOBUF_CONSTEXPR GetRunningAppList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRunningAppList(const GetRunningAppList& from);
  GetRunningAppList(GetRunningAppList&& from) noexcept
    : GetRunningAppList() {
    *this = ::std::move(from);
  }

  inline GetRunningAppList& operator=(const GetRunningAppList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRunningAppList& operator=(GetRunningAppList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRunningAppList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRunningAppList* internal_default_instance() {
    return reinterpret_cast<const GetRunningAppList*>(
               &_GetRunningAppList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetRunningAppList& a, GetRunningAppList& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRunningAppList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRunningAppList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRunningAppList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRunningAppList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRunningAppList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRunningAppList& from) {
    GetRunningAppList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRunningAppList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.GetRunningAppList";
  }
  protected:
  explicit GetRunningAppList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWithThumbnailFieldNumber = 1,
  };
  // required bool with_thumbnail = 1;
  bool has_with_thumbnail() const;
  private:
  bool _internal_has_with_thumbnail() const;
  public:
  void clear_with_thumbnail();
  bool with_thumbnail() const;
  void set_with_thumbnail(bool value);
  private:
  bool _internal_with_thumbnail() const;
  void _internal_set_with_thumbnail(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.GetRunningAppList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool with_thumbnail_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class SetClipboard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.SetClipboard) */ {
 public:
  inline SetClipboard() : SetClipboard(nullptr) {}
  ~SetClipboard() override;
  explicit PROTOBUF_CONSTEXPR SetClipboard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetClipboard(const SetClipboard& from);
  SetClipboard(SetClipboard&& from) noexcept
    : SetClipboard() {
    *this = ::std::move(from);
  }

  inline SetClipboard& operator=(const SetClipboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetClipboard& operator=(SetClipboard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetClipboard& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetClipboard* internal_default_instance() {
    return reinterpret_cast<const SetClipboard*>(
               &_SetClipboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetClipboard& a, SetClipboard& b) {
    a.Swap(&b);
  }
  inline void Swap(SetClipboard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetClipboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetClipboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetClipboard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetClipboard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetClipboard& from) {
    SetClipboard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetClipboard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.SetClipboard";
  }
  protected:
  explicit SetClipboard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // required string content = 1;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.SetClipboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class FocusWin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.FocusWin) */ {
 public:
  inline FocusWin() : FocusWin(nullptr) {}
  ~FocusWin() override;
  explicit PROTOBUF_CONSTEXPR FocusWin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FocusWin(const FocusWin& from);
  FocusWin(FocusWin&& from) noexcept
    : FocusWin() {
    *this = ::std::move(from);
  }

  inline FocusWin& operator=(const FocusWin& from) {
    CopyFrom(from);
    return *this;
  }
  inline FocusWin& operator=(FocusWin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FocusWin& default_instance() {
    return *internal_default_instance();
  }
  static inline const FocusWin* internal_default_instance() {
    return reinterpret_cast<const FocusWin*>(
               &_FocusWin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FocusWin& a, FocusWin& b) {
    a.Swap(&b);
  }
  inline void Swap(FocusWin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FocusWin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FocusWin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FocusWin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FocusWin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FocusWin& from) {
    FocusWin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FocusWin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.FocusWin";
  }
  protected:
  explicit FocusWin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFocusWinFieldNumber = 1,
  };
  // required int32 focus_win = 1;
  bool has_focus_win() const;
  private:
  bool _internal_has_focus_win() const;
  public:
  void clear_focus_win();
  int32_t focus_win() const;
  void set_focus_win(int32_t value);
  private:
  int32_t _internal_focus_win() const;
  void _internal_set_focus_win(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.FocusWin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t focus_win_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class ControlApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.ControlApp) */ {
 public:
  inline ControlApp() : ControlApp(nullptr) {}
  ~ControlApp() override;
  explicit PROTOBUF_CONSTEXPR ControlApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlApp(const ControlApp& from);
  ControlApp(ControlApp&& from) noexcept
    : ControlApp() {
    *this = ::std::move(from);
  }

  inline ControlApp& operator=(const ControlApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlApp& operator=(ControlApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlApp* internal_default_instance() {
    return reinterpret_cast<const ControlApp*>(
               &_ControlApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ControlApp& a, ControlApp& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlApp& from) {
    ControlApp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.ControlApp";
  }
  protected:
  explicit ControlApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 2,
    kDisplayIdFieldNumber = 1,
    kEventTypeFieldNumber = 3,
    kEventValueFieldNumber = 4,
  };
  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required int32 display_id = 1;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // required int32 event_type = 3;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  int32_t event_type() const;
  void set_event_type(int32_t value);
  private:
  int32_t _internal_event_type() const;
  void _internal_set_event_type(int32_t value);
  public:

  // optional int32 event_value = 4;
  bool has_event_value() const;
  private:
  bool _internal_has_event_value() const;
  public:
  void clear_event_value();
  int32_t event_value() const;
  void set_event_value(int32_t value);
  private:
  int32_t _internal_event_value() const;
  void _internal_set_event_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.ControlApp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t display_id_;
    int32_t event_type_;
    int32_t event_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class InsertFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.InsertFile) */ {
 public:
  inline InsertFile() : InsertFile(nullptr) {}
  ~InsertFile() override;
  explicit PROTOBUF_CONSTEXPR InsertFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertFile(const InsertFile& from);
  InsertFile(InsertFile&& from) noexcept
    : InsertFile() {
    *this = ::std::move(from);
  }

  inline InsertFile& operator=(const InsertFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertFile& operator=(InsertFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertFile* internal_default_instance() {
    return reinterpret_cast<const InsertFile*>(
               &_InsertFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InsertFile& a, InsertFile& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertFile& from) {
    InsertFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.InsertFile";
  }
  protected:
  explicit InsertFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kMimeTypeFieldNumber = 2,
  };
  // required string data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required string mime_type = 2;
  bool has_mime_type() const;
  private:
  bool _internal_has_mime_type() const;
  public:
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.InsertFile)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class RemoveFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.RemoveFile) */ {
 public:
  inline RemoveFile() : RemoveFile(nullptr) {}
  ~RemoveFile() override;
  explicit PROTOBUF_CONSTEXPR RemoveFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveFile(const RemoveFile& from);
  RemoveFile(RemoveFile&& from) noexcept
    : RemoveFile() {
    *this = ::std::move(from);
  }

  inline RemoveFile& operator=(const RemoveFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveFile& operator=(RemoveFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveFile* internal_default_instance() {
    return reinterpret_cast<const RemoveFile*>(
               &_RemoveFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RemoveFile& a, RemoveFile& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveFile& from) {
    RemoveFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.RemoveFile";
  }
  protected:
  explicit RemoveFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kMimeTypeFieldNumber = 2,
  };
  // required string data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required string mime_type = 2;
  bool has_mime_type() const;
  private:
  bool _internal_has_mime_type() const;
  public:
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.RemoveFile)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class RequestMediaFiles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.RequestMediaFiles) */ {
 public:
  inline RequestMediaFiles() : RequestMediaFiles(nullptr) {}
  ~RequestMediaFiles() override;
  explicit PROTOBUF_CONSTEXPR RequestMediaFiles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestMediaFiles(const RequestMediaFiles& from);
  RequestMediaFiles(RequestMediaFiles&& from) noexcept
    : RequestMediaFiles() {
    *this = ::std::move(from);
  }

  inline RequestMediaFiles& operator=(const RequestMediaFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestMediaFiles& operator=(RequestMediaFiles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestMediaFiles& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestMediaFiles* internal_default_instance() {
    return reinterpret_cast<const RequestMediaFiles*>(
               &_RequestMediaFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RequestMediaFiles& a, RequestMediaFiles& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestMediaFiles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestMediaFiles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestMediaFiles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestMediaFiles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestMediaFiles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestMediaFiles& from) {
    RequestMediaFiles::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestMediaFiles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.RequestMediaFiles";
  }
  protected:
  explicit RequestMediaFiles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.RequestMediaFiles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class DragFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.DragFile) */ {
 public:
  inline DragFile() : DragFile(nullptr) {}
  ~DragFile() override;
  explicit PROTOBUF_CONSTEXPR DragFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DragFile(const DragFile& from);
  DragFile(DragFile&& from) noexcept
    : DragFile() {
    *this = ::std::move(from);
  }

  inline DragFile& operator=(const DragFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline DragFile& operator=(DragFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DragFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const DragFile* internal_default_instance() {
    return reinterpret_cast<const DragFile*>(
               &_DragFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DragFile& a, DragFile& b) {
    a.Swap(&b);
  }
  inline void Swap(DragFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DragFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DragFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DragFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DragFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DragFile& from) {
    DragFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DragFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.DragFile";
  }
  protected:
  explicit DragFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
    kPackageNameFieldNumber = 2,
    kDisplayIdFieldNumber = 3,
    kHasDoubleDisplayFieldNumber = 4,
  };
  // required string file_path = 1;
  bool has_file_path() const;
  private:
  bool _internal_has_file_path() const;
  public:
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // optional int32 display_id = 3;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // optional bool has_double_display = 4;
  bool has_has_double_display() const;
  private:
  bool _internal_has_has_double_display() const;
  public:
  void clear_has_double_display();
  bool has_double_display() const;
  void set_has_double_display(bool value);
  private:
  bool _internal_has_double_display() const;
  void _internal_set_has_double_display(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.DragFile)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t display_id_;
    bool has_double_display_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class RotationChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.RotationChanged) */ {
 public:
  inline RotationChanged() : RotationChanged(nullptr) {}
  ~RotationChanged() override;
  explicit PROTOBUF_CONSTEXPR RotationChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotationChanged(const RotationChanged& from);
  RotationChanged(RotationChanged&& from) noexcept
    : RotationChanged() {
    *this = ::std::move(from);
  }

  inline RotationChanged& operator=(const RotationChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationChanged& operator=(RotationChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotationChanged* internal_default_instance() {
    return reinterpret_cast<const RotationChanged*>(
               &_RotationChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RotationChanged& a, RotationChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(RotationChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotationChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotationChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RotationChanged& from) {
    RotationChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotationChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.RotationChanged";
  }
  protected:
  explicit RotationChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 2,
    kDisplayIdFieldNumber = 1,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kRotationFieldNumber = 5,
  };
  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required int32 display_id = 1;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // required int32 width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // required int32 height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // required int32 rotation = 5;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  int32_t rotation() const;
  void set_rotation(int32_t value);
  private:
  int32_t _internal_rotation() const;
  void _internal_set_rotation(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.RotationChanged)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t display_id_;
    int32_t width_;
    int32_t height_;
    int32_t rotation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class SetSystemProp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.SetSystemProp) */ {
 public:
  inline SetSystemProp() : SetSystemProp(nullptr) {}
  ~SetSystemProp() override;
  explicit PROTOBUF_CONSTEXPR SetSystemProp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSystemProp(const SetSystemProp& from);
  SetSystemProp(SetSystemProp&& from) noexcept
    : SetSystemProp() {
    *this = ::std::move(from);
  }

  inline SetSystemProp& operator=(const SetSystemProp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSystemProp& operator=(SetSystemProp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSystemProp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSystemProp* internal_default_instance() {
    return reinterpret_cast<const SetSystemProp*>(
               &_SetSystemProp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetSystemProp& a, SetSystemProp& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSystemProp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSystemProp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSystemProp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSystemProp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSystemProp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSystemProp& from) {
    SetSystemProp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSystemProp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.SetSystemProp";
  }
  protected:
  explicit SetSystemProp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldFieldNumber = 2,
    kValueFieldNumber = 3,
    kEventTypeFieldNumber = 1,
  };
  // required string value_field = 2;
  bool has_value_field() const;
  private:
  bool _internal_has_value_field() const;
  public:
  void clear_value_field();
  const std::string& value_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_field();
  PROTOBUF_NODISCARD std::string* release_value_field();
  void set_allocated_value_field(std::string* value_field);
  private:
  const std::string& _internal_value_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_field(const std::string& value);
  std::string* _internal_mutable_value_field();
  public:

  // required string value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // required int32 event_type = 1;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  int32_t event_type() const;
  void set_event_type(int32_t value);
  private:
  int32_t _internal_event_type() const;
  void _internal_set_event_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.SetSystemProp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int32_t event_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class GetSystemProp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.GetSystemProp) */ {
 public:
  inline GetSystemProp() : GetSystemProp(nullptr) {}
  ~GetSystemProp() override;
  explicit PROTOBUF_CONSTEXPR GetSystemProp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSystemProp(const GetSystemProp& from);
  GetSystemProp(GetSystemProp&& from) noexcept
    : GetSystemProp() {
    *this = ::std::move(from);
  }

  inline GetSystemProp& operator=(const GetSystemProp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSystemProp& operator=(GetSystemProp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSystemProp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSystemProp* internal_default_instance() {
    return reinterpret_cast<const GetSystemProp*>(
               &_GetSystemProp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetSystemProp& a, GetSystemProp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSystemProp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSystemProp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSystemProp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSystemProp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSystemProp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSystemProp& from) {
    GetSystemProp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSystemProp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.GetSystemProp";
  }
  protected:
  explicit GetSystemProp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldFieldNumber = 2,
    kEventTypeFieldNumber = 1,
  };
  // required string value_field = 2;
  bool has_value_field() const;
  private:
  bool _internal_has_value_field() const;
  public:
  void clear_value_field();
  const std::string& value_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_field();
  PROTOBUF_NODISCARD std::string* release_value_field();
  void set_allocated_value_field(std::string* value_field);
  private:
  const std::string& _internal_value_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_field(const std::string& value);
  std::string* _internal_mutable_value_field();
  public:

  // required int32 event_type = 1;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  int32_t event_type() const;
  void set_event_type(int32_t value);
  private:
  int32_t _internal_event_type() const;
  void _internal_set_event_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.GetSystemProp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_field_;
    int32_t event_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class UpdateAppWindowSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize) */ {
 public:
  inline UpdateAppWindowSize() : UpdateAppWindowSize(nullptr) {}
  ~UpdateAppWindowSize() override;
  explicit PROTOBUF_CONSTEXPR UpdateAppWindowSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateAppWindowSize(const UpdateAppWindowSize& from);
  UpdateAppWindowSize(UpdateAppWindowSize&& from) noexcept
    : UpdateAppWindowSize() {
    *this = ::std::move(from);
  }

  inline UpdateAppWindowSize& operator=(const UpdateAppWindowSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAppWindowSize& operator=(UpdateAppWindowSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAppWindowSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAppWindowSize* internal_default_instance() {
    return reinterpret_cast<const UpdateAppWindowSize*>(
               &_UpdateAppWindowSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateAppWindowSize& a, UpdateAppWindowSize& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAppWindowSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAppWindowSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAppWindowSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateAppWindowSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateAppWindowSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateAppWindowSize& from) {
    UpdateAppWindowSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAppWindowSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.UpdateAppWindowSize";
  }
  protected:
  explicit UpdateAppWindowSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kDisplayIdFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // required string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required int32 display_id = 2;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // required int32 width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // required int32 height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t display_id_;
    int32_t width_;
    int32_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class SetProxy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.SetProxy) */ {
 public:
  inline SetProxy() : SetProxy(nullptr) {}
  ~SetProxy() override;
  explicit PROTOBUF_CONSTEXPR SetProxy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetProxy(const SetProxy& from);
  SetProxy(SetProxy&& from) noexcept
    : SetProxy() {
    *this = ::std::move(from);
  }

  inline SetProxy& operator=(const SetProxy& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProxy& operator=(SetProxy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetProxy& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetProxy* internal_default_instance() {
    return reinterpret_cast<const SetProxy*>(
               &_SetProxy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SetProxy& a, SetProxy& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProxy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProxy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetProxy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetProxy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetProxy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetProxy& from) {
    SetProxy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProxy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.SetProxy";
  }
  protected:
  explicit SetProxy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 2,
    kTypeFieldNumber = 4,
    kOpenFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // optional string host = 2;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // optional string type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // required bool open = 1;
  bool has_open() const;
  private:
  bool _internal_has_open() const;
  public:
  void clear_open();
  bool open() const;
  void set_open(bool value);
  private:
  bool _internal_open() const;
  void _internal_set_open(bool value);
  public:

  // optional int32 port = 3;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.SetProxy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    bool open_;
    int32_t port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class UpdateDisplaySize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.UpdateDisplaySize) */ {
 public:
  inline UpdateDisplaySize() : UpdateDisplaySize(nullptr) {}
  ~UpdateDisplaySize() override;
  explicit PROTOBUF_CONSTEXPR UpdateDisplaySize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateDisplaySize(const UpdateDisplaySize& from);
  UpdateDisplaySize(UpdateDisplaySize&& from) noexcept
    : UpdateDisplaySize() {
    *this = ::std::move(from);
  }

  inline UpdateDisplaySize& operator=(const UpdateDisplaySize& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateDisplaySize& operator=(UpdateDisplaySize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateDisplaySize& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateDisplaySize* internal_default_instance() {
    return reinterpret_cast<const UpdateDisplaySize*>(
               &_UpdateDisplaySize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateDisplaySize& a, UpdateDisplaySize& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateDisplaySize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateDisplaySize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateDisplaySize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateDisplaySize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateDisplaySize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateDisplaySize& from) {
    UpdateDisplaySize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateDisplaySize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.UpdateDisplaySize";
  }
  protected:
  explicit UpdateDisplaySize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayIdFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // required int32 display_id = 1;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // required int32 width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // required int32 height = 3;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.UpdateDisplaySize)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t display_id_;
    int32_t width_;
    int32_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class AnswerCall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.AnswerCall) */ {
 public:
  inline AnswerCall() : AnswerCall(nullptr) {}
  ~AnswerCall() override;
  explicit PROTOBUF_CONSTEXPR AnswerCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnswerCall(const AnswerCall& from);
  AnswerCall(AnswerCall&& from) noexcept
    : AnswerCall() {
    *this = ::std::move(from);
  }

  inline AnswerCall& operator=(const AnswerCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerCall& operator=(AnswerCall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnswerCall& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnswerCall* internal_default_instance() {
    return reinterpret_cast<const AnswerCall*>(
               &_AnswerCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AnswerCall& a, AnswerCall& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerCall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnswerCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnswerCall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnswerCall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnswerCall& from) {
    AnswerCall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerCall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.AnswerCall";
  }
  protected:
  explicit AnswerCall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnswerFieldNumber = 1,
  };
  // required bool answer = 1;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  bool answer() const;
  void set_answer(bool value);
  private:
  bool _internal_answer() const;
  void _internal_set_answer(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.AnswerCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool answer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class ContainerEnvBootStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus) */ {
 public:
  inline ContainerEnvBootStatus() : ContainerEnvBootStatus(nullptr) {}
  ~ContainerEnvBootStatus() override;
  explicit PROTOBUF_CONSTEXPR ContainerEnvBootStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContainerEnvBootStatus(const ContainerEnvBootStatus& from);
  ContainerEnvBootStatus(ContainerEnvBootStatus&& from) noexcept
    : ContainerEnvBootStatus() {
    *this = ::std::move(from);
  }

  inline ContainerEnvBootStatus& operator=(const ContainerEnvBootStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainerEnvBootStatus& operator=(ContainerEnvBootStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContainerEnvBootStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContainerEnvBootStatus* internal_default_instance() {
    return reinterpret_cast<const ContainerEnvBootStatus*>(
               &_ContainerEnvBootStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ContainerEnvBootStatus& a, ContainerEnvBootStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainerEnvBootStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainerEnvBootStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContainerEnvBootStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContainerEnvBootStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContainerEnvBootStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContainerEnvBootStatus& from) {
    ContainerEnvBootStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainerEnvBootStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus";
  }
  protected:
  explicit ContainerEnvBootStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrInfoFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // optional string err_info = 2;
  bool has_err_info() const;
  private:
  bool _internal_has_err_info() const;
  public:
  void clear_err_info();
  const std::string& err_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_info();
  PROTOBUF_NODISCARD std::string* release_err_info();
  void set_allocated_err_info(std::string* err_info);
  private:
  const std::string& _internal_err_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_info(const std::string& value);
  std::string* _internal_mutable_err_info();
  public:

  // required bool status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_info_;
    bool status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class ActionResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.ActionResult) */ {
 public:
  inline ActionResult() : ActionResult(nullptr) {}
  ~ActionResult() override;
  explicit PROTOBUF_CONSTEXPR ActionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionResult(const ActionResult& from);
  ActionResult(ActionResult&& from) noexcept
    : ActionResult() {
    *this = ::std::move(from);
  }

  inline ActionResult& operator=(const ActionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionResult& operator=(ActionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionResult* internal_default_instance() {
    return reinterpret_cast<const ActionResult*>(
               &_ActionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ActionResult& a, ActionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionResult& from) {
    ActionResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.ActionResult";
  }
  protected:
  explicit ActionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrgCmdFieldNumber = 2,
    kErrInfoFieldNumber = 3,
    kResultFieldNumber = 1,
  };
  // required string org_cmd = 2;
  bool has_org_cmd() const;
  private:
  bool _internal_has_org_cmd() const;
  public:
  void clear_org_cmd();
  const std::string& org_cmd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_org_cmd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_org_cmd();
  PROTOBUF_NODISCARD std::string* release_org_cmd();
  void set_allocated_org_cmd(std::string* org_cmd);
  private:
  const std::string& _internal_org_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_cmd(const std::string& value);
  std::string* _internal_mutable_org_cmd();
  public:

  // optional string err_info = 3;
  bool has_err_info() const;
  private:
  bool _internal_has_err_info() const;
  public:
  void clear_err_info();
  const std::string& err_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_info();
  PROTOBUF_NODISCARD std::string* release_err_info();
  void set_allocated_err_info(std::string* err_info);
  private:
  const std::string& _internal_err_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_info(const std::string& value);
  std::string* _internal_mutable_err_info();
  public:

  // required bool result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.ActionResult)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr org_cmd_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_info_;
    bool result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class EventInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.EventInfo) */ {
 public:
  inline EventInfo() : EventInfo(nullptr) {}
  ~EventInfo() override;
  explicit PROTOBUF_CONSTEXPR EventInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventInfo(const EventInfo& from);
  EventInfo(EventInfo&& from) noexcept
    : EventInfo() {
    *this = ::std::move(from);
  }

  inline EventInfo& operator=(const EventInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventInfo& operator=(EventInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventInfo* internal_default_instance() {
    return reinterpret_cast<const EventInfo*>(
               &_EventInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(EventInfo& a, EventInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EventInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventInfo& from) {
    EventInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.EventInfo";
  }
  protected:
  explicit EventInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 2,
    kEventIdFieldNumber = 1,
  };
  // optional string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required int32 event_id = 1;
  bool has_event_id() const;
  private:
  bool _internal_has_event_id() const;
  public:
  void clear_event_id();
  int32_t event_id() const;
  void set_event_id(int32_t value);
  private:
  int32_t _internal_event_id() const;
  void _internal_set_event_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.EventInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t event_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class InstalledAppItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.InstalledAppItem) */ {
 public:
  inline InstalledAppItem() : InstalledAppItem(nullptr) {}
  ~InstalledAppItem() override;
  explicit PROTOBUF_CONSTEXPR InstalledAppItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstalledAppItem(const InstalledAppItem& from);
  InstalledAppItem(InstalledAppItem&& from) noexcept
    : InstalledAppItem() {
    *this = ::std::move(from);
  }

  inline InstalledAppItem& operator=(const InstalledAppItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstalledAppItem& operator=(InstalledAppItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstalledAppItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstalledAppItem* internal_default_instance() {
    return reinterpret_cast<const InstalledAppItem*>(
               &_InstalledAppItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(InstalledAppItem& a, InstalledAppItem& b) {
    a.Swap(&b);
  }
  inline void Swap(InstalledAppItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstalledAppItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstalledAppItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstalledAppItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstalledAppItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstalledAppItem& from) {
    InstalledAppItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstalledAppItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.InstalledAppItem";
  }
  protected:
  explicit InstalledAppItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 1,
    kPackageNameFieldNumber = 2,
    kVersionNameFieldNumber = 4,
    kAppInfoFieldNumber = 5,
    kVersionCodeFieldNumber = 3,
  };
  // required string app_name = 1;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required string version_name = 4;
  bool has_version_name() const;
  private:
  bool _internal_has_version_name() const;
  public:
  void clear_version_name();
  const std::string& version_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_name();
  PROTOBUF_NODISCARD std::string* release_version_name();
  void set_allocated_version_name(std::string* version_name);
  private:
  const std::string& _internal_version_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_name(const std::string& value);
  std::string* _internal_mutable_version_name();
  public:

  // optional string app_info = 5;
  bool has_app_info() const;
  private:
  bool _internal_has_app_info() const;
  public:
  void clear_app_info();
  const std::string& app_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_info();
  PROTOBUF_NODISCARD std::string* release_app_info();
  void set_allocated_app_info(std::string* app_info);
  private:
  const std::string& _internal_app_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_info(const std::string& value);
  std::string* _internal_mutable_app_info();
  public:

  // required int64 version_code = 3;
  bool has_version_code() const;
  private:
  bool _internal_has_version_code() const;
  public:
  void clear_version_code();
  int64_t version_code() const;
  void set_version_code(int64_t value);
  private:
  int64_t _internal_version_code() const;
  void _internal_set_version_code(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.InstalledAppItem)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_info_;
    int64_t version_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class InstalledAppList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.InstalledAppList) */ {
 public:
  inline InstalledAppList() : InstalledAppList(nullptr) {}
  ~InstalledAppList() override;
  explicit PROTOBUF_CONSTEXPR InstalledAppList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstalledAppList(const InstalledAppList& from);
  InstalledAppList(InstalledAppList&& from) noexcept
    : InstalledAppList() {
    *this = ::std::move(from);
  }

  inline InstalledAppList& operator=(const InstalledAppList& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstalledAppList& operator=(InstalledAppList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstalledAppList& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstalledAppList* internal_default_instance() {
    return reinterpret_cast<const InstalledAppList*>(
               &_InstalledAppList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(InstalledAppList& a, InstalledAppList& b) {
    a.Swap(&b);
  }
  inline void Swap(InstalledAppList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstalledAppList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstalledAppList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstalledAppList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstalledAppList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstalledAppList& from) {
    InstalledAppList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstalledAppList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.InstalledAppList";
  }
  protected:
  explicit InstalledAppList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated .cn.kylinos.kmre.kmrecore.InstalledAppItem item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::cn::kylinos::kmre::kmrecore::InstalledAppItem* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::InstalledAppItem >*
      mutable_item();
  private:
  const ::cn::kylinos::kmre::kmrecore::InstalledAppItem& _internal_item(int index) const;
  ::cn::kylinos::kmre::kmrecore::InstalledAppItem* _internal_add_item();
  public:
  const ::cn::kylinos::kmre::kmrecore::InstalledAppItem& item(int index) const;
  ::cn::kylinos::kmre::kmrecore::InstalledAppItem* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::InstalledAppItem >&
      item() const;

  // required int32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.InstalledAppList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::InstalledAppItem > item_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class RunningAppItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.RunningAppItem) */ {
 public:
  inline RunningAppItem() : RunningAppItem(nullptr) {}
  ~RunningAppItem() override;
  explicit PROTOBUF_CONSTEXPR RunningAppItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunningAppItem(const RunningAppItem& from);
  RunningAppItem(RunningAppItem&& from) noexcept
    : RunningAppItem() {
    *this = ::std::move(from);
  }

  inline RunningAppItem& operator=(const RunningAppItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningAppItem& operator=(RunningAppItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunningAppItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunningAppItem* internal_default_instance() {
    return reinterpret_cast<const RunningAppItem*>(
               &_RunningAppItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RunningAppItem& a, RunningAppItem& b) {
    a.Swap(&b);
  }
  inline void Swap(RunningAppItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunningAppItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunningAppItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunningAppItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunningAppItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunningAppItem& from) {
    RunningAppItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunningAppItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.RunningAppItem";
  }
  protected:
  explicit RunningAppItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 1,
    kPackageNameFieldNumber = 2,
  };
  // required string app_name = 1;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.RunningAppItem)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class RunningAppList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.RunningAppList) */ {
 public:
  inline RunningAppList() : RunningAppList(nullptr) {}
  ~RunningAppList() override;
  explicit PROTOBUF_CONSTEXPR RunningAppList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunningAppList(const RunningAppList& from);
  RunningAppList(RunningAppList&& from) noexcept
    : RunningAppList() {
    *this = ::std::move(from);
  }

  inline RunningAppList& operator=(const RunningAppList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningAppList& operator=(RunningAppList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunningAppList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunningAppList* internal_default_instance() {
    return reinterpret_cast<const RunningAppList*>(
               &_RunningAppList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RunningAppList& a, RunningAppList& b) {
    a.Swap(&b);
  }
  inline void Swap(RunningAppList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunningAppList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunningAppList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunningAppList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunningAppList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunningAppList& from) {
    RunningAppList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunningAppList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.RunningAppList";
  }
  protected:
  explicit RunningAppList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated .cn.kylinos.kmre.kmrecore.RunningAppItem item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::cn::kylinos::kmre::kmrecore::RunningAppItem* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::RunningAppItem >*
      mutable_item();
  private:
  const ::cn::kylinos::kmre::kmrecore::RunningAppItem& _internal_item(int index) const;
  ::cn::kylinos::kmre::kmrecore::RunningAppItem* _internal_add_item();
  public:
  const ::cn::kylinos::kmre::kmrecore::RunningAppItem& item(int index) const;
  ::cn::kylinos::kmre::kmrecore::RunningAppItem* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::RunningAppItem >&
      item() const;

  // required int32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.RunningAppList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::RunningAppItem > item_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit PROTOBUF_CONSTEXPR Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Notification& from) {
    Notification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kAppNameFieldNumber = 2,
    kTextFieldNumber = 3,
    kTitleFieldNumber = 7,
    kDisplayIdFieldNumber = 4,
    kHideFieldNumber = 5,
    kIncomingCallFieldNumber = 6,
  };
  // required string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required string app_name = 2;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // optional string text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string title = 7;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional int32 display_id = 4;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // optional bool hide = 5;
  bool has_hide() const;
  private:
  bool _internal_has_hide() const;
  public:
  void clear_hide();
  bool hide() const;
  void set_hide(bool value);
  private:
  bool _internal_hide() const;
  void _internal_set_hide(bool value);
  public:

  // optional bool incoming_call = 6;
  bool has_incoming_call() const;
  private:
  bool _internal_has_incoming_call() const;
  public:
  void clear_incoming_call();
  bool incoming_call() const;
  void set_incoming_call(bool value);
  private:
  bool _internal_incoming_call() const;
  void _internal_set_incoming_call(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.Notification)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    int32_t display_id_;
    bool hide_;
    bool incoming_call_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class LaunchResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.LaunchResult) */ {
 public:
  inline LaunchResult() : LaunchResult(nullptr) {}
  ~LaunchResult() override;
  explicit PROTOBUF_CONSTEXPR LaunchResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaunchResult(const LaunchResult& from);
  LaunchResult(LaunchResult&& from) noexcept
    : LaunchResult() {
    *this = ::std::move(from);
  }

  inline LaunchResult& operator=(const LaunchResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaunchResult& operator=(LaunchResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaunchResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaunchResult* internal_default_instance() {
    return reinterpret_cast<const LaunchResult*>(
               &_LaunchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(LaunchResult& a, LaunchResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LaunchResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaunchResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaunchResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaunchResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaunchResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LaunchResult& from) {
    LaunchResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaunchResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.LaunchResult";
  }
  protected:
  explicit LaunchResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 1,
    kPackageNameFieldNumber = 2,
    kDisplayIdFieldNumber = 4,
    kWidthFieldNumber = 5,
    kHeightFieldNumber = 6,
    kDensityFieldNumber = 7,
    kResultFieldNumber = 3,
    kFullscreenFieldNumber = 8,
    kExistsFieldNumber = 9,
    kAppResumedFieldNumber = 10,
  };
  // required string app_name = 1;
  bool has_app_name() const;
  private:
  bool _internal_has_app_name() const;
  public:
  void clear_app_name();
  const std::string& app_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_name();
  PROTOBUF_NODISCARD std::string* release_app_name();
  void set_allocated_app_name(std::string* app_name);
  private:
  const std::string& _internal_app_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_name(const std::string& value);
  std::string* _internal_mutable_app_name();
  public:

  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required int32 display_id = 4;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // required int32 width = 5;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // required int32 height = 6;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // required int32 density = 7;
  bool has_density() const;
  private:
  bool _internal_has_density() const;
  public:
  void clear_density();
  int32_t density() const;
  void set_density(int32_t value);
  private:
  int32_t _internal_density() const;
  void _internal_set_density(int32_t value);
  public:

  // required bool result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // required bool fullscreen = 8;
  bool has_fullscreen() const;
  private:
  bool _internal_has_fullscreen() const;
  public:
  void clear_fullscreen();
  bool fullscreen() const;
  void set_fullscreen(bool value);
  private:
  bool _internal_fullscreen() const;
  void _internal_set_fullscreen(bool value);
  public:

  // optional bool exists = 9;
  bool has_exists() const;
  private:
  bool _internal_has_exists() const;
  public:
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);
  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);
  public:

  // optional bool app_resumed = 10;
  bool has_app_resumed() const;
  private:
  bool _internal_has_app_resumed() const;
  public:
  void clear_app_resumed();
  bool app_resumed() const;
  void set_app_resumed(bool value);
  private:
  bool _internal_app_resumed() const;
  void _internal_set_app_resumed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.LaunchResult)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t display_id_;
    int32_t width_;
    int32_t height_;
    int32_t density_;
    bool result_;
    bool fullscreen_;
    bool exists_;
    bool app_resumed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class CloseResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.CloseResult) */ {
 public:
  inline CloseResult() : CloseResult(nullptr) {}
  ~CloseResult() override;
  explicit PROTOBUF_CONSTEXPR CloseResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseResult(const CloseResult& from);
  CloseResult(CloseResult&& from) noexcept
    : CloseResult() {
    *this = ::std::move(from);
  }

  inline CloseResult& operator=(const CloseResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseResult& operator=(CloseResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseResult* internal_default_instance() {
    return reinterpret_cast<const CloseResult*>(
               &_CloseResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CloseResult& a, CloseResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloseResult& from) {
    CloseResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.CloseResult";
  }
  protected:
  explicit CloseResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // required string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required bool result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.CloseResult)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    bool result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class VirtualScreenFocusResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult) */ {
 public:
  inline VirtualScreenFocusResult() : VirtualScreenFocusResult(nullptr) {}
  ~VirtualScreenFocusResult() override;
  explicit PROTOBUF_CONSTEXPR VirtualScreenFocusResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualScreenFocusResult(const VirtualScreenFocusResult& from);
  VirtualScreenFocusResult(VirtualScreenFocusResult&& from) noexcept
    : VirtualScreenFocusResult() {
    *this = ::std::move(from);
  }

  inline VirtualScreenFocusResult& operator=(const VirtualScreenFocusResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualScreenFocusResult& operator=(VirtualScreenFocusResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualScreenFocusResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualScreenFocusResult* internal_default_instance() {
    return reinterpret_cast<const VirtualScreenFocusResult*>(
               &_VirtualScreenFocusResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(VirtualScreenFocusResult& a, VirtualScreenFocusResult& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualScreenFocusResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualScreenFocusResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirtualScreenFocusResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirtualScreenFocusResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualScreenFocusResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VirtualScreenFocusResult& from) {
    VirtualScreenFocusResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualScreenFocusResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult";
  }
  protected:
  explicit VirtualScreenFocusResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // required int32 display_id = 1;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // required bool result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t display_id_;
    bool result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class InputMethodRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.InputMethodRequest) */ {
 public:
  inline InputMethodRequest() : InputMethodRequest(nullptr) {}
  ~InputMethodRequest() override;
  explicit PROTOBUF_CONSTEXPR InputMethodRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputMethodRequest(const InputMethodRequest& from);
  InputMethodRequest(InputMethodRequest&& from) noexcept
    : InputMethodRequest() {
    *this = ::std::move(from);
  }

  inline InputMethodRequest& operator=(const InputMethodRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputMethodRequest& operator=(InputMethodRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputMethodRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputMethodRequest* internal_default_instance() {
    return reinterpret_cast<const InputMethodRequest*>(
               &_InputMethodRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(InputMethodRequest& a, InputMethodRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InputMethodRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputMethodRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputMethodRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputMethodRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputMethodRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputMethodRequest& from) {
    InputMethodRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputMethodRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.InputMethodRequest";
  }
  protected:
  explicit InputMethodRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 2,
    kDisplayIdFieldNumber = 1,
    kRetFieldNumber = 3,
    kXPosFieldNumber = 4,
    kYPosFieldNumber = 5,
  };
  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required int32 display_id = 1;
  bool has_display_id() const;
  private:
  bool _internal_has_display_id() const;
  public:
  void clear_display_id();
  int32_t display_id() const;
  void set_display_id(int32_t value);
  private:
  int32_t _internal_display_id() const;
  void _internal_set_display_id(int32_t value);
  public:

  // required bool ret = 3;
  bool has_ret() const;
  private:
  bool _internal_has_ret() const;
  public:
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // optional int32 x_pos = 4;
  bool has_x_pos() const;
  private:
  bool _internal_has_x_pos() const;
  public:
  void clear_x_pos();
  int32_t x_pos() const;
  void set_x_pos(int32_t value);
  private:
  int32_t _internal_x_pos() const;
  void _internal_set_x_pos(int32_t value);
  public:

  // optional int32 y_pos = 5;
  bool has_y_pos() const;
  private:
  bool _internal_has_y_pos() const;
  public:
  void clear_y_pos();
  int32_t y_pos() const;
  void set_y_pos(int32_t value);
  private:
  int32_t _internal_y_pos() const;
  void _internal_set_y_pos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.InputMethodRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t display_id_;
    bool ret_;
    int32_t x_pos_;
    int32_t y_pos_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class SingleFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.SingleFile) */ {
 public:
  inline SingleFile() : SingleFile(nullptr) {}
  ~SingleFile() override;
  explicit PROTOBUF_CONSTEXPR SingleFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleFile(const SingleFile& from);
  SingleFile(SingleFile&& from) noexcept
    : SingleFile() {
    *this = ::std::move(from);
  }

  inline SingleFile& operator=(const SingleFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleFile& operator=(SingleFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleFile* internal_default_instance() {
    return reinterpret_cast<const SingleFile*>(
               &_SingleFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SingleFile& a, SingleFile& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleFile& from) {
    SingleFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.SingleFile";
  }
  protected:
  explicit SingleFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kMimeTypeFieldNumber = 2,
    kPackageNameFieldNumber = 3,
  };
  // required string data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required string mime_type = 2;
  bool has_mime_type() const;
  private:
  bool _internal_has_mime_type() const;
  public:
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // optional string package_name = 3;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.SingleFile)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class FilesList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.FilesList) */ {
 public:
  inline FilesList() : FilesList(nullptr) {}
  ~FilesList() override;
  explicit PROTOBUF_CONSTEXPR FilesList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilesList(const FilesList& from);
  FilesList(FilesList&& from) noexcept
    : FilesList() {
    *this = ::std::move(from);
  }

  inline FilesList& operator=(const FilesList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilesList& operator=(FilesList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilesList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilesList* internal_default_instance() {
    return reinterpret_cast<const FilesList*>(
               &_FilesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(FilesList& a, FilesList& b) {
    a.Swap(&b);
  }
  inline void Swap(FilesList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilesList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilesList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilesList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilesList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FilesList& from) {
    FilesList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilesList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.FilesList";
  }
  protected:
  explicit FilesList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 2,
    kTypeFieldNumber = 1,
    kSizeFieldNumber = 3,
  };
  // repeated .cn.kylinos.kmre.kmrecore.SingleFile item = 2;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::cn::kylinos::kmre::kmrecore::SingleFile* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::SingleFile >*
      mutable_item();
  private:
  const ::cn::kylinos::kmre::kmrecore::SingleFile& _internal_item(int index) const;
  ::cn::kylinos::kmre::kmrecore::SingleFile* _internal_add_item();
  public:
  const ::cn::kylinos::kmre::kmrecore::SingleFile& item(int index) const;
  ::cn::kylinos::kmre::kmrecore::SingleFile* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::SingleFile >&
      item() const;

  // required int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // required int32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.FilesList)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::SingleFile > item_;
    int32_t type_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class MediaPlayStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.MediaPlayStatus) */ {
 public:
  inline MediaPlayStatus() : MediaPlayStatus(nullptr) {}
  ~MediaPlayStatus() override;
  explicit PROTOBUF_CONSTEXPR MediaPlayStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaPlayStatus(const MediaPlayStatus& from);
  MediaPlayStatus(MediaPlayStatus&& from) noexcept
    : MediaPlayStatus() {
    *this = ::std::move(from);
  }

  inline MediaPlayStatus& operator=(const MediaPlayStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaPlayStatus& operator=(MediaPlayStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaPlayStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaPlayStatus* internal_default_instance() {
    return reinterpret_cast<const MediaPlayStatus*>(
               &_MediaPlayStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(MediaPlayStatus& a, MediaPlayStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaPlayStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaPlayStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaPlayStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaPlayStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaPlayStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MediaPlayStatus& from) {
    MediaPlayStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaPlayStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.MediaPlayStatus";
  }
  protected:
  explicit MediaPlayStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // required bool result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.MediaPlayStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class AppMultiplier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.AppMultiplier) */ {
 public:
  inline AppMultiplier() : AppMultiplier(nullptr) {}
  ~AppMultiplier() override;
  explicit PROTOBUF_CONSTEXPR AppMultiplier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMultiplier(const AppMultiplier& from);
  AppMultiplier(AppMultiplier&& from) noexcept
    : AppMultiplier() {
    *this = ::std::move(from);
  }

  inline AppMultiplier& operator=(const AppMultiplier& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMultiplier& operator=(AppMultiplier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMultiplier& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMultiplier* internal_default_instance() {
    return reinterpret_cast<const AppMultiplier*>(
               &_AppMultiplier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(AppMultiplier& a, AppMultiplier& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMultiplier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMultiplier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppMultiplier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppMultiplier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMultiplier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppMultiplier& from) {
    AppMultiplier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMultiplier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.AppMultiplier";
  }
  protected:
  explicit AppMultiplier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kInfoFieldNumber = 3,
    kMultiplierFieldNumber = 2,
  };
  // required string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // optional string info = 3;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // required int32 multiplier = 2;
  bool has_multiplier() const;
  private:
  bool _internal_has_multiplier() const;
  public:
  void clear_multiplier();
  int32_t multiplier() const;
  void set_multiplier(int32_t value);
  private:
  int32_t _internal_multiplier() const;
  void _internal_set_multiplier(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.AppMultiplier)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    int32_t multiplier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class AppMultiplierList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.AppMultiplierList) */ {
 public:
  inline AppMultiplierList() : AppMultiplierList(nullptr) {}
  ~AppMultiplierList() override;
  explicit PROTOBUF_CONSTEXPR AppMultiplierList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMultiplierList(const AppMultiplierList& from);
  AppMultiplierList(AppMultiplierList&& from) noexcept
    : AppMultiplierList() {
    *this = ::std::move(from);
  }

  inline AppMultiplierList& operator=(const AppMultiplierList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMultiplierList& operator=(AppMultiplierList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMultiplierList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMultiplierList* internal_default_instance() {
    return reinterpret_cast<const AppMultiplierList*>(
               &_AppMultiplierList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(AppMultiplierList& a, AppMultiplierList& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMultiplierList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMultiplierList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppMultiplierList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppMultiplierList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMultiplierList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppMultiplierList& from) {
    AppMultiplierList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMultiplierList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.AppMultiplierList";
  }
  protected:
  explicit AppMultiplierList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated .cn.kylinos.kmre.kmrecore.AppMultiplier item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::cn::kylinos::kmre::kmrecore::AppMultiplier* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::AppMultiplier >*
      mutable_item();
  private:
  const ::cn::kylinos::kmre::kmrecore::AppMultiplier& _internal_item(int index) const;
  ::cn::kylinos::kmre::kmrecore::AppMultiplier* _internal_add_item();
  public:
  const ::cn::kylinos::kmre::kmrecore::AppMultiplier& item(int index) const;
  ::cn::kylinos::kmre::kmrecore::AppMultiplier* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::AppMultiplier >&
      item() const;

  // required int32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.AppMultiplierList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::AppMultiplier > item_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.Info) */ {
 public:
  inline Info() : Info(nullptr) {}
  ~Info() override;
  explicit PROTOBUF_CONSTEXPR Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Info(const Info& from);
  Info(Info&& from) noexcept
    : Info() {
    *this = ::std::move(from);
  }

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Info& operator=(Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Info& a, Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Info& from) {
    Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.Info";
  }
  protected:
  explicit Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kValue3FieldNumber = 4,
    kValue4FieldNumber = 5,
    kValue1FieldNumber = 2,
    kValue2FieldNumber = 3,
  };
  // required string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // optional string value3 = 4;
  bool has_value3() const;
  private:
  bool _internal_has_value3() const;
  public:
  void clear_value3();
  const std::string& value3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value3();
  PROTOBUF_NODISCARD std::string* release_value3();
  void set_allocated_value3(std::string* value3);
  private:
  const std::string& _internal_value3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value3(const std::string& value);
  std::string* _internal_mutable_value3();
  public:

  // optional string value4 = 5;
  bool has_value4() const;
  private:
  bool _internal_has_value4() const;
  public:
  void clear_value4();
  const std::string& value4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value4();
  PROTOBUF_NODISCARD std::string* release_value4();
  void set_allocated_value4(std::string* value4);
  private:
  const std::string& _internal_value4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value4(const std::string& value);
  std::string* _internal_mutable_value4();
  public:

  // optional int32 value1 = 2;
  bool has_value1() const;
  private:
  bool _internal_has_value1() const;
  public:
  void clear_value1();
  int32_t value1() const;
  void set_value1(int32_t value);
  private:
  int32_t _internal_value1() const;
  void _internal_set_value1(int32_t value);
  public:

  // optional int32 value2 = 3;
  bool has_value2() const;
  private:
  bool _internal_has_value2() const;
  public:
  void clear_value2();
  int32_t value2() const;
  void set_value2(int32_t value);
  private:
  int32_t _internal_value2() const;
  void _internal_set_value2(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value3_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value4_;
    int32_t value1_;
    int32_t value2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class GetInfoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.GetInfoList) */ {
 public:
  inline GetInfoList() : GetInfoList(nullptr) {}
  ~GetInfoList() override;
  explicit PROTOBUF_CONSTEXPR GetInfoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInfoList(const GetInfoList& from);
  GetInfoList(GetInfoList&& from) noexcept
    : GetInfoList() {
    *this = ::std::move(from);
  }

  inline GetInfoList& operator=(const GetInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoList& operator=(GetInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInfoList* internal_default_instance() {
    return reinterpret_cast<const GetInfoList*>(
               &_GetInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetInfoList& a, GetInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInfoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInfoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInfoList& from) {
    GetInfoList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInfoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.GetInfoList";
  }
  protected:
  explicit GetInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kTypeFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // repeated .cn.kylinos.kmre.kmrecore.Info item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  ::cn::kylinos::kmre::kmrecore::Info* mutable_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::Info >*
      mutable_item();
  private:
  const ::cn::kylinos::kmre::kmrecore::Info& _internal_item(int index) const;
  ::cn::kylinos::kmre::kmrecore::Info* _internal_add_item();
  public:
  const ::cn::kylinos::kmre::kmrecore::Info& item(int index) const;
  ::cn::kylinos::kmre::kmrecore::Info* add_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::Info >&
      item() const;

  // required string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // required int32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.GetInfoList)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::Info > item_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class ResponseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.ResponseInfo) */ {
 public:
  inline ResponseInfo() : ResponseInfo(nullptr) {}
  ~ResponseInfo() override;
  explicit PROTOBUF_CONSTEXPR ResponseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseInfo(const ResponseInfo& from);
  ResponseInfo(ResponseInfo&& from) noexcept
    : ResponseInfo() {
    *this = ::std::move(from);
  }

  inline ResponseInfo& operator=(const ResponseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseInfo& operator=(ResponseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseInfo*>(
               &_ResponseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ResponseInfo& a, ResponseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseInfo& from) {
    ResponseInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.ResponseInfo";
  }
  protected:
  explicit ResponseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 2,
    kCategoryFieldNumber = 3,
    kInfoFieldNumber = 5,
    kEventIdFieldNumber = 1,
    kRetFieldNumber = 4,
  };
  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required string category = 3;
  bool has_category() const;
  private:
  bool _internal_has_category() const;
  public:
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // optional string info = 5;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // required int32 event_id = 1;
  bool has_event_id() const;
  private:
  bool _internal_has_event_id() const;
  public:
  void clear_event_id();
  int32_t event_id() const;
  void set_event_id(int32_t value);
  private:
  int32_t _internal_event_id() const;
  void _internal_set_event_id(int32_t value);
  public:

  // required int32 ret = 4;
  bool has_ret() const;
  private:
  bool _internal_has_ret() const;
  public:
  void clear_ret();
  int32_t ret() const;
  void set_ret(int32_t value);
  private:
  int32_t _internal_ret() const;
  void _internal_set_ret(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.ResponseInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    int32_t event_id_;
    int32_t ret_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class MultiplierSwitch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.MultiplierSwitch) */ {
 public:
  inline MultiplierSwitch() : MultiplierSwitch(nullptr) {}
  ~MultiplierSwitch() override;
  explicit PROTOBUF_CONSTEXPR MultiplierSwitch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiplierSwitch(const MultiplierSwitch& from);
  MultiplierSwitch(MultiplierSwitch&& from) noexcept
    : MultiplierSwitch() {
    *this = ::std::move(from);
  }

  inline MultiplierSwitch& operator=(const MultiplierSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiplierSwitch& operator=(MultiplierSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiplierSwitch& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiplierSwitch* internal_default_instance() {
    return reinterpret_cast<const MultiplierSwitch*>(
               &_MultiplierSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MultiplierSwitch& a, MultiplierSwitch& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiplierSwitch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiplierSwitch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiplierSwitch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiplierSwitch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiplierSwitch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MultiplierSwitch& from) {
    MultiplierSwitch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplierSwitch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.MultiplierSwitch";
  }
  protected:
  explicit MultiplierSwitch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 2,
    kEventIdFieldNumber = 1,
    kEnableFieldNumber = 3,
  };
  // required string package_name = 2;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required int32 event_id = 1;
  bool has_event_id() const;
  private:
  bool _internal_has_event_id() const;
  public:
  void clear_event_id();
  int32_t event_id() const;
  void set_event_id(int32_t value);
  private:
  int32_t _internal_event_id() const;
  void _internal_set_event_id(int32_t value);
  public:

  // required bool enable = 3;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.MultiplierSwitch)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t event_id_;
    bool enable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class LinkOpen final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.LinkOpen) */ {
 public:
  inline LinkOpen() : LinkOpen(nullptr) {}
  ~LinkOpen() override;
  explicit PROTOBUF_CONSTEXPR LinkOpen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinkOpen(const LinkOpen& from);
  LinkOpen(LinkOpen&& from) noexcept
    : LinkOpen() {
    *this = ::std::move(from);
  }

  inline LinkOpen& operator=(const LinkOpen& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinkOpen& operator=(LinkOpen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinkOpen& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinkOpen* internal_default_instance() {
    return reinterpret_cast<const LinkOpen*>(
               &_LinkOpen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(LinkOpen& a, LinkOpen& b) {
    a.Swap(&b);
  }
  inline void Swap(LinkOpen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinkOpen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinkOpen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinkOpen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinkOpen& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinkOpen& from) {
    LinkOpen::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkOpen* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.LinkOpen";
  }
  protected:
  explicit LinkOpen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // required string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.LinkOpen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class UpdatePackageStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.UpdatePackageStatus) */ {
 public:
  inline UpdatePackageStatus() : UpdatePackageStatus(nullptr) {}
  ~UpdatePackageStatus() override;
  explicit PROTOBUF_CONSTEXPR UpdatePackageStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePackageStatus(const UpdatePackageStatus& from);
  UpdatePackageStatus(UpdatePackageStatus&& from) noexcept
    : UpdatePackageStatus() {
    *this = ::std::move(from);
  }

  inline UpdatePackageStatus& operator=(const UpdatePackageStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePackageStatus& operator=(UpdatePackageStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePackageStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePackageStatus* internal_default_instance() {
    return reinterpret_cast<const UpdatePackageStatus*>(
               &_UpdatePackageStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(UpdatePackageStatus& a, UpdatePackageStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePackageStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePackageStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePackageStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePackageStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePackageStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdatePackageStatus& from) {
    UpdatePackageStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePackageStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.UpdatePackageStatus";
  }
  protected:
  explicit UpdatePackageStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageNameFieldNumber = 1,
    kStatusFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // required string package_name = 1;
  bool has_package_name() const;
  private:
  bool _internal_has_package_name() const;
  public:
  void clear_package_name();
  const std::string& package_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* package_name);
  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(const std::string& value);
  std::string* _internal_mutable_package_name();
  public:

  // required int32 status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // optional int32 type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.UpdatePackageStatus)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_name_;
    int32_t status_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class SendSystemProp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.SendSystemProp) */ {
 public:
  inline SendSystemProp() : SendSystemProp(nullptr) {}
  ~SendSystemProp() override;
  explicit PROTOBUF_CONSTEXPR SendSystemProp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendSystemProp(const SendSystemProp& from);
  SendSystemProp(SendSystemProp&& from) noexcept
    : SendSystemProp() {
    *this = ::std::move(from);
  }

  inline SendSystemProp& operator=(const SendSystemProp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendSystemProp& operator=(SendSystemProp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendSystemProp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendSystemProp* internal_default_instance() {
    return reinterpret_cast<const SendSystemProp*>(
               &_SendSystemProp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SendSystemProp& a, SendSystemProp& b) {
    a.Swap(&b);
  }
  inline void Swap(SendSystemProp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendSystemProp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendSystemProp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendSystemProp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendSystemProp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendSystemProp& from) {
    SendSystemProp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendSystemProp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.SendSystemProp";
  }
  protected:
  explicit SendSystemProp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldFieldNumber = 2,
    kValueFieldNumber = 3,
    kEventTypeFieldNumber = 1,
  };
  // required string value_field = 2;
  bool has_value_field() const;
  private:
  bool _internal_has_value_field() const;
  public:
  void clear_value_field();
  const std::string& value_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_field();
  PROTOBUF_NODISCARD std::string* release_value_field();
  void set_allocated_value_field(std::string* value_field);
  private:
  const std::string& _internal_value_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_field(const std::string& value);
  std::string* _internal_mutable_value_field();
  public:

  // required string value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // required int32 event_type = 1;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  int32_t event_type() const;
  void set_event_type(int32_t value);
  private:
  int32_t _internal_event_type() const;
  void _internal_set_event_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.SendSystemProp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int32_t event_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// -------------------------------------------------------------------

class EventSequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.kylinos.kmre.kmrecore.EventSequence) */ {
 public:
  inline EventSequence() : EventSequence(nullptr) {}
  ~EventSequence() override;
  explicit PROTOBUF_CONSTEXPR EventSequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventSequence(const EventSequence& from);
  EventSequence(EventSequence&& from) noexcept
    : EventSequence() {
    *this = ::std::move(from);
  }

  inline EventSequence& operator=(const EventSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventSequence& operator=(EventSequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventSequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventSequence* internal_default_instance() {
    return reinterpret_cast<const EventSequence*>(
               &_EventSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(EventSequence& a, EventSequence& b) {
    a.Swap(&b);
  }
  inline void Swap(EventSequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventSequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventSequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventSequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventSequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventSequence& from) {
    EventSequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cn.kylinos.kmre.kmrecore.EventSequence";
  }
  protected:
  explicit EventSequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationFieldNumber = 1,
    kEventInfoFieldNumber = 2,
    kLaunchResultFieldNumber = 3,
    kCloseResultFieldNumber = 4,
    kSetClipboardFieldNumber = 5,
    kFocusResultFieldNumber = 6,
    kInputmethodRequestFieldNumber = 7,
    kFilesListFieldNumber = 8,
    kMediaplayStatusFieldNumber = 9,
    kAppMultipliersFieldNumber = 10,
    kResponseInfoFieldNumber = 11,
    kMultiplierSwitchFieldNumber = 12,
    kLinkOpenFieldNumber = 13,
    kUpdatePackageStatusFieldNumber = 14,
    kSystemPropFieldNumber = 15,
    kGetInfoListFieldNumber = 16,
    kContainerEnvBootStatusFieldNumber = 17,
  };
  // optional .cn.kylinos.kmre.kmrecore.Notification notification = 1;
  bool has_notification() const;
  private:
  bool _internal_has_notification() const;
  public:
  void clear_notification();
  const ::cn::kylinos::kmre::kmrecore::Notification& notification() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::Notification* release_notification();
  ::cn::kylinos::kmre::kmrecore::Notification* mutable_notification();
  void set_allocated_notification(::cn::kylinos::kmre::kmrecore::Notification* notification);
  private:
  const ::cn::kylinos::kmre::kmrecore::Notification& _internal_notification() const;
  ::cn::kylinos::kmre::kmrecore::Notification* _internal_mutable_notification();
  public:
  void unsafe_arena_set_allocated_notification(
      ::cn::kylinos::kmre::kmrecore::Notification* notification);
  ::cn::kylinos::kmre::kmrecore::Notification* unsafe_arena_release_notification();

  // optional .cn.kylinos.kmre.kmrecore.EventInfo event_info = 2;
  bool has_event_info() const;
  private:
  bool _internal_has_event_info() const;
  public:
  void clear_event_info();
  const ::cn::kylinos::kmre::kmrecore::EventInfo& event_info() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::EventInfo* release_event_info();
  ::cn::kylinos::kmre::kmrecore::EventInfo* mutable_event_info();
  void set_allocated_event_info(::cn::kylinos::kmre::kmrecore::EventInfo* event_info);
  private:
  const ::cn::kylinos::kmre::kmrecore::EventInfo& _internal_event_info() const;
  ::cn::kylinos::kmre::kmrecore::EventInfo* _internal_mutable_event_info();
  public:
  void unsafe_arena_set_allocated_event_info(
      ::cn::kylinos::kmre::kmrecore::EventInfo* event_info);
  ::cn::kylinos::kmre::kmrecore::EventInfo* unsafe_arena_release_event_info();

  // optional .cn.kylinos.kmre.kmrecore.LaunchResult launch_result = 3;
  bool has_launch_result() const;
  private:
  bool _internal_has_launch_result() const;
  public:
  void clear_launch_result();
  const ::cn::kylinos::kmre::kmrecore::LaunchResult& launch_result() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::LaunchResult* release_launch_result();
  ::cn::kylinos::kmre::kmrecore::LaunchResult* mutable_launch_result();
  void set_allocated_launch_result(::cn::kylinos::kmre::kmrecore::LaunchResult* launch_result);
  private:
  const ::cn::kylinos::kmre::kmrecore::LaunchResult& _internal_launch_result() const;
  ::cn::kylinos::kmre::kmrecore::LaunchResult* _internal_mutable_launch_result();
  public:
  void unsafe_arena_set_allocated_launch_result(
      ::cn::kylinos::kmre::kmrecore::LaunchResult* launch_result);
  ::cn::kylinos::kmre::kmrecore::LaunchResult* unsafe_arena_release_launch_result();

  // optional .cn.kylinos.kmre.kmrecore.CloseResult close_result = 4;
  bool has_close_result() const;
  private:
  bool _internal_has_close_result() const;
  public:
  void clear_close_result();
  const ::cn::kylinos::kmre::kmrecore::CloseResult& close_result() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::CloseResult* release_close_result();
  ::cn::kylinos::kmre::kmrecore::CloseResult* mutable_close_result();
  void set_allocated_close_result(::cn::kylinos::kmre::kmrecore::CloseResult* close_result);
  private:
  const ::cn::kylinos::kmre::kmrecore::CloseResult& _internal_close_result() const;
  ::cn::kylinos::kmre::kmrecore::CloseResult* _internal_mutable_close_result();
  public:
  void unsafe_arena_set_allocated_close_result(
      ::cn::kylinos::kmre::kmrecore::CloseResult* close_result);
  ::cn::kylinos::kmre::kmrecore::CloseResult* unsafe_arena_release_close_result();

  // optional .cn.kylinos.kmre.kmrecore.SetClipboard set_clipboard = 5;
  bool has_set_clipboard() const;
  private:
  bool _internal_has_set_clipboard() const;
  public:
  void clear_set_clipboard();
  const ::cn::kylinos::kmre::kmrecore::SetClipboard& set_clipboard() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::SetClipboard* release_set_clipboard();
  ::cn::kylinos::kmre::kmrecore::SetClipboard* mutable_set_clipboard();
  void set_allocated_set_clipboard(::cn::kylinos::kmre::kmrecore::SetClipboard* set_clipboard);
  private:
  const ::cn::kylinos::kmre::kmrecore::SetClipboard& _internal_set_clipboard() const;
  ::cn::kylinos::kmre::kmrecore::SetClipboard* _internal_mutable_set_clipboard();
  public:
  void unsafe_arena_set_allocated_set_clipboard(
      ::cn::kylinos::kmre::kmrecore::SetClipboard* set_clipboard);
  ::cn::kylinos::kmre::kmrecore::SetClipboard* unsafe_arena_release_set_clipboard();

  // optional .cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult focus_result = 6;
  bool has_focus_result() const;
  private:
  bool _internal_has_focus_result() const;
  public:
  void clear_focus_result();
  const ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult& focus_result() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* release_focus_result();
  ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* mutable_focus_result();
  void set_allocated_focus_result(::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* focus_result);
  private:
  const ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult& _internal_focus_result() const;
  ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* _internal_mutable_focus_result();
  public:
  void unsafe_arena_set_allocated_focus_result(
      ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* focus_result);
  ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* unsafe_arena_release_focus_result();

  // optional .cn.kylinos.kmre.kmrecore.InputMethodRequest inputmethod_request = 7;
  bool has_inputmethod_request() const;
  private:
  bool _internal_has_inputmethod_request() const;
  public:
  void clear_inputmethod_request();
  const ::cn::kylinos::kmre::kmrecore::InputMethodRequest& inputmethod_request() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::InputMethodRequest* release_inputmethod_request();
  ::cn::kylinos::kmre::kmrecore::InputMethodRequest* mutable_inputmethod_request();
  void set_allocated_inputmethod_request(::cn::kylinos::kmre::kmrecore::InputMethodRequest* inputmethod_request);
  private:
  const ::cn::kylinos::kmre::kmrecore::InputMethodRequest& _internal_inputmethod_request() const;
  ::cn::kylinos::kmre::kmrecore::InputMethodRequest* _internal_mutable_inputmethod_request();
  public:
  void unsafe_arena_set_allocated_inputmethod_request(
      ::cn::kylinos::kmre::kmrecore::InputMethodRequest* inputmethod_request);
  ::cn::kylinos::kmre::kmrecore::InputMethodRequest* unsafe_arena_release_inputmethod_request();

  // optional .cn.kylinos.kmre.kmrecore.FilesList files_list = 8;
  bool has_files_list() const;
  private:
  bool _internal_has_files_list() const;
  public:
  void clear_files_list();
  const ::cn::kylinos::kmre::kmrecore::FilesList& files_list() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::FilesList* release_files_list();
  ::cn::kylinos::kmre::kmrecore::FilesList* mutable_files_list();
  void set_allocated_files_list(::cn::kylinos::kmre::kmrecore::FilesList* files_list);
  private:
  const ::cn::kylinos::kmre::kmrecore::FilesList& _internal_files_list() const;
  ::cn::kylinos::kmre::kmrecore::FilesList* _internal_mutable_files_list();
  public:
  void unsafe_arena_set_allocated_files_list(
      ::cn::kylinos::kmre::kmrecore::FilesList* files_list);
  ::cn::kylinos::kmre::kmrecore::FilesList* unsafe_arena_release_files_list();

  // optional .cn.kylinos.kmre.kmrecore.MediaPlayStatus mediaplay_status = 9;
  bool has_mediaplay_status() const;
  private:
  bool _internal_has_mediaplay_status() const;
  public:
  void clear_mediaplay_status();
  const ::cn::kylinos::kmre::kmrecore::MediaPlayStatus& mediaplay_status() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* release_mediaplay_status();
  ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* mutable_mediaplay_status();
  void set_allocated_mediaplay_status(::cn::kylinos::kmre::kmrecore::MediaPlayStatus* mediaplay_status);
  private:
  const ::cn::kylinos::kmre::kmrecore::MediaPlayStatus& _internal_mediaplay_status() const;
  ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* _internal_mutable_mediaplay_status();
  public:
  void unsafe_arena_set_allocated_mediaplay_status(
      ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* mediaplay_status);
  ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* unsafe_arena_release_mediaplay_status();

  // optional .cn.kylinos.kmre.kmrecore.AppMultiplierList app_multipliers = 10;
  bool has_app_multipliers() const;
  private:
  bool _internal_has_app_multipliers() const;
  public:
  void clear_app_multipliers();
  const ::cn::kylinos::kmre::kmrecore::AppMultiplierList& app_multipliers() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::AppMultiplierList* release_app_multipliers();
  ::cn::kylinos::kmre::kmrecore::AppMultiplierList* mutable_app_multipliers();
  void set_allocated_app_multipliers(::cn::kylinos::kmre::kmrecore::AppMultiplierList* app_multipliers);
  private:
  const ::cn::kylinos::kmre::kmrecore::AppMultiplierList& _internal_app_multipliers() const;
  ::cn::kylinos::kmre::kmrecore::AppMultiplierList* _internal_mutable_app_multipliers();
  public:
  void unsafe_arena_set_allocated_app_multipliers(
      ::cn::kylinos::kmre::kmrecore::AppMultiplierList* app_multipliers);
  ::cn::kylinos::kmre::kmrecore::AppMultiplierList* unsafe_arena_release_app_multipliers();

  // optional .cn.kylinos.kmre.kmrecore.ResponseInfo response_info = 11;
  bool has_response_info() const;
  private:
  bool _internal_has_response_info() const;
  public:
  void clear_response_info();
  const ::cn::kylinos::kmre::kmrecore::ResponseInfo& response_info() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::ResponseInfo* release_response_info();
  ::cn::kylinos::kmre::kmrecore::ResponseInfo* mutable_response_info();
  void set_allocated_response_info(::cn::kylinos::kmre::kmrecore::ResponseInfo* response_info);
  private:
  const ::cn::kylinos::kmre::kmrecore::ResponseInfo& _internal_response_info() const;
  ::cn::kylinos::kmre::kmrecore::ResponseInfo* _internal_mutable_response_info();
  public:
  void unsafe_arena_set_allocated_response_info(
      ::cn::kylinos::kmre::kmrecore::ResponseInfo* response_info);
  ::cn::kylinos::kmre::kmrecore::ResponseInfo* unsafe_arena_release_response_info();

  // optional .cn.kylinos.kmre.kmrecore.MultiplierSwitch multiplier_switch = 12;
  bool has_multiplier_switch() const;
  private:
  bool _internal_has_multiplier_switch() const;
  public:
  void clear_multiplier_switch();
  const ::cn::kylinos::kmre::kmrecore::MultiplierSwitch& multiplier_switch() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* release_multiplier_switch();
  ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* mutable_multiplier_switch();
  void set_allocated_multiplier_switch(::cn::kylinos::kmre::kmrecore::MultiplierSwitch* multiplier_switch);
  private:
  const ::cn::kylinos::kmre::kmrecore::MultiplierSwitch& _internal_multiplier_switch() const;
  ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* _internal_mutable_multiplier_switch();
  public:
  void unsafe_arena_set_allocated_multiplier_switch(
      ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* multiplier_switch);
  ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* unsafe_arena_release_multiplier_switch();

  // optional .cn.kylinos.kmre.kmrecore.LinkOpen link_open = 13;
  bool has_link_open() const;
  private:
  bool _internal_has_link_open() const;
  public:
  void clear_link_open();
  const ::cn::kylinos::kmre::kmrecore::LinkOpen& link_open() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::LinkOpen* release_link_open();
  ::cn::kylinos::kmre::kmrecore::LinkOpen* mutable_link_open();
  void set_allocated_link_open(::cn::kylinos::kmre::kmrecore::LinkOpen* link_open);
  private:
  const ::cn::kylinos::kmre::kmrecore::LinkOpen& _internal_link_open() const;
  ::cn::kylinos::kmre::kmrecore::LinkOpen* _internal_mutable_link_open();
  public:
  void unsafe_arena_set_allocated_link_open(
      ::cn::kylinos::kmre::kmrecore::LinkOpen* link_open);
  ::cn::kylinos::kmre::kmrecore::LinkOpen* unsafe_arena_release_link_open();

  // optional .cn.kylinos.kmre.kmrecore.UpdatePackageStatus update_package_status = 14;
  bool has_update_package_status() const;
  private:
  bool _internal_has_update_package_status() const;
  public:
  void clear_update_package_status();
  const ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus& update_package_status() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* release_update_package_status();
  ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* mutable_update_package_status();
  void set_allocated_update_package_status(::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* update_package_status);
  private:
  const ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus& _internal_update_package_status() const;
  ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* _internal_mutable_update_package_status();
  public:
  void unsafe_arena_set_allocated_update_package_status(
      ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* update_package_status);
  ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* unsafe_arena_release_update_package_status();

  // optional .cn.kylinos.kmre.kmrecore.SendSystemProp system_prop = 15;
  bool has_system_prop() const;
  private:
  bool _internal_has_system_prop() const;
  public:
  void clear_system_prop();
  const ::cn::kylinos::kmre::kmrecore::SendSystemProp& system_prop() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::SendSystemProp* release_system_prop();
  ::cn::kylinos::kmre::kmrecore::SendSystemProp* mutable_system_prop();
  void set_allocated_system_prop(::cn::kylinos::kmre::kmrecore::SendSystemProp* system_prop);
  private:
  const ::cn::kylinos::kmre::kmrecore::SendSystemProp& _internal_system_prop() const;
  ::cn::kylinos::kmre::kmrecore::SendSystemProp* _internal_mutable_system_prop();
  public:
  void unsafe_arena_set_allocated_system_prop(
      ::cn::kylinos::kmre::kmrecore::SendSystemProp* system_prop);
  ::cn::kylinos::kmre::kmrecore::SendSystemProp* unsafe_arena_release_system_prop();

  // optional .cn.kylinos.kmre.kmrecore.GetInfoList get_info_list = 16;
  bool has_get_info_list() const;
  private:
  bool _internal_has_get_info_list() const;
  public:
  void clear_get_info_list();
  const ::cn::kylinos::kmre::kmrecore::GetInfoList& get_info_list() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::GetInfoList* release_get_info_list();
  ::cn::kylinos::kmre::kmrecore::GetInfoList* mutable_get_info_list();
  void set_allocated_get_info_list(::cn::kylinos::kmre::kmrecore::GetInfoList* get_info_list);
  private:
  const ::cn::kylinos::kmre::kmrecore::GetInfoList& _internal_get_info_list() const;
  ::cn::kylinos::kmre::kmrecore::GetInfoList* _internal_mutable_get_info_list();
  public:
  void unsafe_arena_set_allocated_get_info_list(
      ::cn::kylinos::kmre::kmrecore::GetInfoList* get_info_list);
  ::cn::kylinos::kmre::kmrecore::GetInfoList* unsafe_arena_release_get_info_list();

  // optional .cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus container_env_boot_status = 17;
  bool has_container_env_boot_status() const;
  private:
  bool _internal_has_container_env_boot_status() const;
  public:
  void clear_container_env_boot_status();
  const ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus& container_env_boot_status() const;
  PROTOBUF_NODISCARD ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* release_container_env_boot_status();
  ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* mutable_container_env_boot_status();
  void set_allocated_container_env_boot_status(::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* container_env_boot_status);
  private:
  const ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus& _internal_container_env_boot_status() const;
  ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* _internal_mutable_container_env_boot_status();
  public:
  void unsafe_arena_set_allocated_container_env_boot_status(
      ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* container_env_boot_status);
  ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* unsafe_arena_release_container_env_boot_status();

  // @@protoc_insertion_point(class_scope:cn.kylinos.kmre.kmrecore.EventSequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cn::kylinos::kmre::kmrecore::Notification* notification_;
    ::cn::kylinos::kmre::kmrecore::EventInfo* event_info_;
    ::cn::kylinos::kmre::kmrecore::LaunchResult* launch_result_;
    ::cn::kylinos::kmre::kmrecore::CloseResult* close_result_;
    ::cn::kylinos::kmre::kmrecore::SetClipboard* set_clipboard_;
    ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* focus_result_;
    ::cn::kylinos::kmre::kmrecore::InputMethodRequest* inputmethod_request_;
    ::cn::kylinos::kmre::kmrecore::FilesList* files_list_;
    ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* mediaplay_status_;
    ::cn::kylinos::kmre::kmrecore::AppMultiplierList* app_multipliers_;
    ::cn::kylinos::kmre::kmrecore::ResponseInfo* response_info_;
    ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* multiplier_switch_;
    ::cn::kylinos::kmre::kmrecore::LinkOpen* link_open_;
    ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* update_package_status_;
    ::cn::kylinos::kmre::kmrecore::SendSystemProp* system_prop_;
    ::cn::kylinos::kmre::kmrecore::GetInfoList* get_info_list_;
    ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* container_env_boot_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_KmreCore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InstallApp

// required string file_name = 1;
inline bool InstallApp::_internal_has_file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstallApp::has_file_name() const {
  return _internal_has_file_name();
}
inline void InstallApp::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstallApp::file_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstallApp.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallApp::set_file_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstallApp.file_name)
}
inline std::string* InstallApp::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InstallApp.file_name)
  return _s;
}
inline const std::string& InstallApp::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void InstallApp::_internal_set_file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallApp::_internal_mutable_file_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstallApp::release_file_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InstallApp.file_name)
  if (!_internal_has_file_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.file_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstallApp::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InstallApp.file_name)
}

// required string app_name = 2;
inline bool InstallApp::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstallApp::has_app_name() const {
  return _internal_has_app_name();
}
inline void InstallApp::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstallApp::app_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstallApp.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallApp::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstallApp.app_name)
}
inline std::string* InstallApp::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InstallApp.app_name)
  return _s;
}
inline const std::string& InstallApp::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void InstallApp::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallApp::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstallApp::release_app_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InstallApp.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstallApp::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InstallApp.app_name)
}

// required string package_name = 3;
inline bool InstallApp::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InstallApp::has_package_name() const {
  return _internal_has_package_name();
}
inline void InstallApp::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InstallApp::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstallApp.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallApp::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstallApp.package_name)
}
inline std::string* InstallApp::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InstallApp.package_name)
  return _s;
}
inline const std::string& InstallApp::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void InstallApp::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallApp::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstallApp::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InstallApp.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstallApp::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InstallApp.package_name)
}

// -------------------------------------------------------------------

// UninstallApp

// required string package_name = 1;
inline bool UninstallApp::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UninstallApp::has_package_name() const {
  return _internal_has_package_name();
}
inline void UninstallApp::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UninstallApp::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UninstallApp.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UninstallApp::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UninstallApp.package_name)
}
inline std::string* UninstallApp::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.UninstallApp.package_name)
  return _s;
}
inline const std::string& UninstallApp::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void UninstallApp::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UninstallApp::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UninstallApp::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.UninstallApp.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UninstallApp::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.UninstallApp.package_name)
}

// -------------------------------------------------------------------

// LaunchApp

// required string package_name = 1;
inline bool LaunchApp::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LaunchApp::has_package_name() const {
  return _internal_has_package_name();
}
inline void LaunchApp::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LaunchApp::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchApp.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LaunchApp::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchApp.package_name)
}
inline std::string* LaunchApp::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.LaunchApp.package_name)
  return _s;
}
inline const std::string& LaunchApp::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void LaunchApp::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LaunchApp::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LaunchApp::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.LaunchApp.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LaunchApp::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.LaunchApp.package_name)
}

// required bool fullscreen = 2;
inline bool LaunchApp::_internal_has_fullscreen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LaunchApp::has_fullscreen() const {
  return _internal_has_fullscreen();
}
inline void LaunchApp::clear_fullscreen() {
  _impl_.fullscreen_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool LaunchApp::_internal_fullscreen() const {
  return _impl_.fullscreen_;
}
inline bool LaunchApp::fullscreen() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchApp.fullscreen)
  return _internal_fullscreen();
}
inline void LaunchApp::_internal_set_fullscreen(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fullscreen_ = value;
}
inline void LaunchApp::set_fullscreen(bool value) {
  _internal_set_fullscreen(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchApp.fullscreen)
}

// required int32 width = 3;
inline bool LaunchApp::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LaunchApp::has_width() const {
  return _internal_has_width();
}
inline void LaunchApp::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t LaunchApp::_internal_width() const {
  return _impl_.width_;
}
inline int32_t LaunchApp::width() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchApp.width)
  return _internal_width();
}
inline void LaunchApp::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.width_ = value;
}
inline void LaunchApp::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchApp.width)
}

// required int32 height = 4;
inline bool LaunchApp::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LaunchApp::has_height() const {
  return _internal_has_height();
}
inline void LaunchApp::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t LaunchApp::_internal_height() const {
  return _impl_.height_;
}
inline int32_t LaunchApp::height() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchApp.height)
  return _internal_height();
}
inline void LaunchApp::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.height_ = value;
}
inline void LaunchApp::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchApp.height)
}

// required int32 density = 5;
inline bool LaunchApp::_internal_has_density() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LaunchApp::has_density() const {
  return _internal_has_density();
}
inline void LaunchApp::clear_density() {
  _impl_.density_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t LaunchApp::_internal_density() const {
  return _impl_.density_;
}
inline int32_t LaunchApp::density() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchApp.density)
  return _internal_density();
}
inline void LaunchApp::_internal_set_density(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.density_ = value;
}
inline void LaunchApp::set_density(int32_t value) {
  _internal_set_density(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchApp.density)
}

// -------------------------------------------------------------------

// CloseApp

// required string app_name = 1;
inline bool CloseApp::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CloseApp::has_app_name() const {
  return _internal_has_app_name();
}
inline void CloseApp::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CloseApp::app_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.CloseApp.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloseApp::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.CloseApp.app_name)
}
inline std::string* CloseApp::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.CloseApp.app_name)
  return _s;
}
inline const std::string& CloseApp::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void CloseApp::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CloseApp::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CloseApp::release_app_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.CloseApp.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CloseApp::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.CloseApp.app_name)
}

// required string package_name = 2;
inline bool CloseApp::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CloseApp::has_package_name() const {
  return _internal_has_package_name();
}
inline void CloseApp::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CloseApp::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.CloseApp.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloseApp::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.CloseApp.package_name)
}
inline std::string* CloseApp::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.CloseApp.package_name)
  return _s;
}
inline const std::string& CloseApp::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void CloseApp::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CloseApp::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CloseApp::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.CloseApp.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CloseApp::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.CloseApp.package_name)
}

// optional bool force_kill = 3;
inline bool CloseApp::_internal_has_force_kill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CloseApp::has_force_kill() const {
  return _internal_has_force_kill();
}
inline void CloseApp::clear_force_kill() {
  _impl_.force_kill_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CloseApp::_internal_force_kill() const {
  return _impl_.force_kill_;
}
inline bool CloseApp::force_kill() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.CloseApp.force_kill)
  return _internal_force_kill();
}
inline void CloseApp::_internal_set_force_kill(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.force_kill_ = value;
}
inline void CloseApp::set_force_kill(bool value) {
  _internal_set_force_kill(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.CloseApp.force_kill)
}

// -------------------------------------------------------------------

// GetInstalledAppList

// optional bool include_hide_app = 1;
inline bool GetInstalledAppList::_internal_has_include_hide_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetInstalledAppList::has_include_hide_app() const {
  return _internal_has_include_hide_app();
}
inline void GetInstalledAppList::clear_include_hide_app() {
  _impl_.include_hide_app_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool GetInstalledAppList::_internal_include_hide_app() const {
  return _impl_.include_hide_app_;
}
inline bool GetInstalledAppList::include_hide_app() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.GetInstalledAppList.include_hide_app)
  return _internal_include_hide_app();
}
inline void GetInstalledAppList::_internal_set_include_hide_app(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.include_hide_app_ = value;
}
inline void GetInstalledAppList::set_include_hide_app(bool value) {
  _internal_set_include_hide_app(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.GetInstalledAppList.include_hide_app)
}

// -------------------------------------------------------------------

// GetRunningAppList

// required bool with_thumbnail = 1;
inline bool GetRunningAppList::_internal_has_with_thumbnail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetRunningAppList::has_with_thumbnail() const {
  return _internal_has_with_thumbnail();
}
inline void GetRunningAppList::clear_with_thumbnail() {
  _impl_.with_thumbnail_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool GetRunningAppList::_internal_with_thumbnail() const {
  return _impl_.with_thumbnail_;
}
inline bool GetRunningAppList::with_thumbnail() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.GetRunningAppList.with_thumbnail)
  return _internal_with_thumbnail();
}
inline void GetRunningAppList::_internal_set_with_thumbnail(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.with_thumbnail_ = value;
}
inline void GetRunningAppList::set_with_thumbnail(bool value) {
  _internal_set_with_thumbnail(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.GetRunningAppList.with_thumbnail)
}

// -------------------------------------------------------------------

// SetClipboard

// required string content = 1;
inline bool SetClipboard::_internal_has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetClipboard::has_content() const {
  return _internal_has_content();
}
inline void SetClipboard::clear_content() {
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetClipboard::content() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SetClipboard.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetClipboard::set_content(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SetClipboard.content)
}
inline std::string* SetClipboard::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SetClipboard.content)
  return _s;
}
inline const std::string& SetClipboard::_internal_content() const {
  return _impl_.content_.Get();
}
inline void SetClipboard::_internal_set_content(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* SetClipboard::_internal_mutable_content() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* SetClipboard::release_content() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SetClipboard.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetClipboard::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SetClipboard.content)
}

// -------------------------------------------------------------------

// FocusWin

// required int32 focus_win = 1;
inline bool FocusWin::_internal_has_focus_win() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FocusWin::has_focus_win() const {
  return _internal_has_focus_win();
}
inline void FocusWin::clear_focus_win() {
  _impl_.focus_win_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t FocusWin::_internal_focus_win() const {
  return _impl_.focus_win_;
}
inline int32_t FocusWin::focus_win() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.FocusWin.focus_win)
  return _internal_focus_win();
}
inline void FocusWin::_internal_set_focus_win(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.focus_win_ = value;
}
inline void FocusWin::set_focus_win(int32_t value) {
  _internal_set_focus_win(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.FocusWin.focus_win)
}

// -------------------------------------------------------------------

// ControlApp

// required int32 display_id = 1;
inline bool ControlApp::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ControlApp::has_display_id() const {
  return _internal_has_display_id();
}
inline void ControlApp::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ControlApp::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t ControlApp::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ControlApp.display_id)
  return _internal_display_id();
}
inline void ControlApp::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.display_id_ = value;
}
inline void ControlApp::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ControlApp.display_id)
}

// required string package_name = 2;
inline bool ControlApp::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ControlApp::has_package_name() const {
  return _internal_has_package_name();
}
inline void ControlApp::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ControlApp::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ControlApp.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlApp::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ControlApp.package_name)
}
inline std::string* ControlApp::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.ControlApp.package_name)
  return _s;
}
inline const std::string& ControlApp::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void ControlApp::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ControlApp::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ControlApp::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.ControlApp.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ControlApp::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.ControlApp.package_name)
}

// required int32 event_type = 3;
inline bool ControlApp::_internal_has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ControlApp::has_event_type() const {
  return _internal_has_event_type();
}
inline void ControlApp::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t ControlApp::_internal_event_type() const {
  return _impl_.event_type_;
}
inline int32_t ControlApp::event_type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ControlApp.event_type)
  return _internal_event_type();
}
inline void ControlApp::_internal_set_event_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.event_type_ = value;
}
inline void ControlApp::set_event_type(int32_t value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ControlApp.event_type)
}

// optional int32 event_value = 4;
inline bool ControlApp::_internal_has_event_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ControlApp::has_event_value() const {
  return _internal_has_event_value();
}
inline void ControlApp::clear_event_value() {
  _impl_.event_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t ControlApp::_internal_event_value() const {
  return _impl_.event_value_;
}
inline int32_t ControlApp::event_value() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ControlApp.event_value)
  return _internal_event_value();
}
inline void ControlApp::_internal_set_event_value(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.event_value_ = value;
}
inline void ControlApp::set_event_value(int32_t value) {
  _internal_set_event_value(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ControlApp.event_value)
}

// -------------------------------------------------------------------

// InsertFile

// required string data = 1;
inline bool InsertFile::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InsertFile::has_data() const {
  return _internal_has_data();
}
inline void InsertFile::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InsertFile::data() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InsertFile.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertFile::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InsertFile.data)
}
inline std::string* InsertFile::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InsertFile.data)
  return _s;
}
inline const std::string& InsertFile::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InsertFile::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertFile::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertFile::release_data() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InsertFile.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InsertFile::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InsertFile.data)
}

// required string mime_type = 2;
inline bool InsertFile::_internal_has_mime_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InsertFile::has_mime_type() const {
  return _internal_has_mime_type();
}
inline void InsertFile::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InsertFile::mime_type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InsertFile.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertFile::set_mime_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InsertFile.mime_type)
}
inline std::string* InsertFile::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InsertFile.mime_type)
  return _s;
}
inline const std::string& InsertFile::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void InsertFile::_internal_set_mime_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertFile::_internal_mutable_mime_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertFile::release_mime_type() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InsertFile.mime_type)
  if (!_internal_has_mime_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InsertFile::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InsertFile.mime_type)
}

// -------------------------------------------------------------------

// RemoveFile

// required string data = 1;
inline bool RemoveFile::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemoveFile::has_data() const {
  return _internal_has_data();
}
inline void RemoveFile::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoveFile::data() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RemoveFile.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveFile::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RemoveFile.data)
}
inline std::string* RemoveFile::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.RemoveFile.data)
  return _s;
}
inline const std::string& RemoveFile::_internal_data() const {
  return _impl_.data_.Get();
}
inline void RemoveFile::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveFile::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveFile::release_data() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.RemoveFile.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RemoveFile::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.RemoveFile.data)
}

// required string mime_type = 2;
inline bool RemoveFile::_internal_has_mime_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoveFile::has_mime_type() const {
  return _internal_has_mime_type();
}
inline void RemoveFile::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RemoveFile::mime_type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RemoveFile.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveFile::set_mime_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RemoveFile.mime_type)
}
inline std::string* RemoveFile::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.RemoveFile.mime_type)
  return _s;
}
inline const std::string& RemoveFile::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void RemoveFile::_internal_set_mime_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveFile::_internal_mutable_mime_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveFile::release_mime_type() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.RemoveFile.mime_type)
  if (!_internal_has_mime_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RemoveFile::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.RemoveFile.mime_type)
}

// -------------------------------------------------------------------

// RequestMediaFiles

// required int32 type = 1;
inline bool RequestMediaFiles::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestMediaFiles::has_type() const {
  return _internal_has_type();
}
inline void RequestMediaFiles::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RequestMediaFiles::_internal_type() const {
  return _impl_.type_;
}
inline int32_t RequestMediaFiles::type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RequestMediaFiles.type)
  return _internal_type();
}
inline void RequestMediaFiles::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void RequestMediaFiles::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RequestMediaFiles.type)
}

// -------------------------------------------------------------------

// DragFile

// required string file_path = 1;
inline bool DragFile::_internal_has_file_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DragFile::has_file_path() const {
  return _internal_has_file_path();
}
inline void DragFile::clear_file_path() {
  _impl_.file_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DragFile::file_path() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.DragFile.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DragFile::set_file_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.DragFile.file_path)
}
inline std::string* DragFile::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.DragFile.file_path)
  return _s;
}
inline const std::string& DragFile::_internal_file_path() const {
  return _impl_.file_path_.Get();
}
inline void DragFile::_internal_set_file_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* DragFile::_internal_mutable_file_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* DragFile::release_file_path() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.DragFile.file_path)
  if (!_internal_has_file_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.file_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_path_.IsDefault()) {
    _impl_.file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DragFile::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.file_path_.SetAllocated(file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_path_.IsDefault()) {
    _impl_.file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.DragFile.file_path)
}

// required string package_name = 2;
inline bool DragFile::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DragFile::has_package_name() const {
  return _internal_has_package_name();
}
inline void DragFile::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DragFile::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.DragFile.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DragFile::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.DragFile.package_name)
}
inline std::string* DragFile::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.DragFile.package_name)
  return _s;
}
inline const std::string& DragFile::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void DragFile::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DragFile::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DragFile::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.DragFile.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DragFile::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.DragFile.package_name)
}

// optional int32 display_id = 3;
inline bool DragFile::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DragFile::has_display_id() const {
  return _internal_has_display_id();
}
inline void DragFile::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DragFile::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t DragFile::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.DragFile.display_id)
  return _internal_display_id();
}
inline void DragFile::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.display_id_ = value;
}
inline void DragFile::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.DragFile.display_id)
}

// optional bool has_double_display = 4;
inline bool DragFile::_internal_has_has_double_display() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DragFile::has_has_double_display() const {
  return _internal_has_has_double_display();
}
inline void DragFile::clear_has_double_display() {
  _impl_.has_double_display_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DragFile::_internal_has_double_display() const {
  return _impl_.has_double_display_;
}
inline bool DragFile::has_double_display() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.DragFile.has_double_display)
  return _internal_has_double_display();
}
inline void DragFile::_internal_set_has_double_display(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.has_double_display_ = value;
}
inline void DragFile::set_has_double_display(bool value) {
  _internal_set_has_double_display(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.DragFile.has_double_display)
}

// -------------------------------------------------------------------

// RotationChanged

// required int32 display_id = 1;
inline bool RotationChanged::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RotationChanged::has_display_id() const {
  return _internal_has_display_id();
}
inline void RotationChanged::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t RotationChanged::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t RotationChanged::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RotationChanged.display_id)
  return _internal_display_id();
}
inline void RotationChanged::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.display_id_ = value;
}
inline void RotationChanged::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RotationChanged.display_id)
}

// required string package_name = 2;
inline bool RotationChanged::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RotationChanged::has_package_name() const {
  return _internal_has_package_name();
}
inline void RotationChanged::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RotationChanged::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RotationChanged.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RotationChanged::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RotationChanged.package_name)
}
inline std::string* RotationChanged::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.RotationChanged.package_name)
  return _s;
}
inline const std::string& RotationChanged::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void RotationChanged::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RotationChanged::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RotationChanged::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.RotationChanged.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RotationChanged::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.RotationChanged.package_name)
}

// required int32 width = 3;
inline bool RotationChanged::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RotationChanged::has_width() const {
  return _internal_has_width();
}
inline void RotationChanged::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t RotationChanged::_internal_width() const {
  return _impl_.width_;
}
inline int32_t RotationChanged::width() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RotationChanged.width)
  return _internal_width();
}
inline void RotationChanged::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.width_ = value;
}
inline void RotationChanged::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RotationChanged.width)
}

// required int32 height = 4;
inline bool RotationChanged::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RotationChanged::has_height() const {
  return _internal_has_height();
}
inline void RotationChanged::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t RotationChanged::_internal_height() const {
  return _impl_.height_;
}
inline int32_t RotationChanged::height() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RotationChanged.height)
  return _internal_height();
}
inline void RotationChanged::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.height_ = value;
}
inline void RotationChanged::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RotationChanged.height)
}

// required int32 rotation = 5;
inline bool RotationChanged::_internal_has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RotationChanged::has_rotation() const {
  return _internal_has_rotation();
}
inline void RotationChanged::clear_rotation() {
  _impl_.rotation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t RotationChanged::_internal_rotation() const {
  return _impl_.rotation_;
}
inline int32_t RotationChanged::rotation() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RotationChanged.rotation)
  return _internal_rotation();
}
inline void RotationChanged::_internal_set_rotation(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rotation_ = value;
}
inline void RotationChanged::set_rotation(int32_t value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RotationChanged.rotation)
}

// -------------------------------------------------------------------

// SetSystemProp

// required int32 event_type = 1;
inline bool SetSystemProp::_internal_has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SetSystemProp::has_event_type() const {
  return _internal_has_event_type();
}
inline void SetSystemProp::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SetSystemProp::_internal_event_type() const {
  return _impl_.event_type_;
}
inline int32_t SetSystemProp::event_type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SetSystemProp.event_type)
  return _internal_event_type();
}
inline void SetSystemProp::_internal_set_event_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.event_type_ = value;
}
inline void SetSystemProp::set_event_type(int32_t value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SetSystemProp.event_type)
}

// required string value_field = 2;
inline bool SetSystemProp::_internal_has_value_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetSystemProp::has_value_field() const {
  return _internal_has_value_field();
}
inline void SetSystemProp::clear_value_field() {
  _impl_.value_field_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetSystemProp::value_field() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SetSystemProp.value_field)
  return _internal_value_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSystemProp::set_value_field(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SetSystemProp.value_field)
}
inline std::string* SetSystemProp::mutable_value_field() {
  std::string* _s = _internal_mutable_value_field();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SetSystemProp.value_field)
  return _s;
}
inline const std::string& SetSystemProp::_internal_value_field() const {
  return _impl_.value_field_.Get();
}
inline void SetSystemProp::_internal_set_value_field(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_field_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSystemProp::_internal_mutable_value_field() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_field_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSystemProp::release_value_field() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SetSystemProp.value_field)
  if (!_internal_has_value_field()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_field_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_field_.IsDefault()) {
    _impl_.value_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetSystemProp::set_allocated_value_field(std::string* value_field) {
  if (value_field != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_field_.SetAllocated(value_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_field_.IsDefault()) {
    _impl_.value_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SetSystemProp.value_field)
}

// required string value = 3;
inline bool SetSystemProp::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetSystemProp::has_value() const {
  return _internal_has_value();
}
inline void SetSystemProp::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetSystemProp::value() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SetSystemProp.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSystemProp::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SetSystemProp.value)
}
inline std::string* SetSystemProp::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SetSystemProp.value)
  return _s;
}
inline const std::string& SetSystemProp::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SetSystemProp::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSystemProp::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSystemProp::release_value() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SetSystemProp.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetSystemProp::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SetSystemProp.value)
}

// -------------------------------------------------------------------

// GetSystemProp

// required int32 event_type = 1;
inline bool GetSystemProp::_internal_has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetSystemProp::has_event_type() const {
  return _internal_has_event_type();
}
inline void GetSystemProp::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t GetSystemProp::_internal_event_type() const {
  return _impl_.event_type_;
}
inline int32_t GetSystemProp::event_type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.GetSystemProp.event_type)
  return _internal_event_type();
}
inline void GetSystemProp::_internal_set_event_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.event_type_ = value;
}
inline void GetSystemProp::set_event_type(int32_t value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.GetSystemProp.event_type)
}

// required string value_field = 2;
inline bool GetSystemProp::_internal_has_value_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetSystemProp::has_value_field() const {
  return _internal_has_value_field();
}
inline void GetSystemProp::clear_value_field() {
  _impl_.value_field_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetSystemProp::value_field() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.GetSystemProp.value_field)
  return _internal_value_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSystemProp::set_value_field(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.GetSystemProp.value_field)
}
inline std::string* GetSystemProp::mutable_value_field() {
  std::string* _s = _internal_mutable_value_field();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.GetSystemProp.value_field)
  return _s;
}
inline const std::string& GetSystemProp::_internal_value_field() const {
  return _impl_.value_field_.Get();
}
inline void GetSystemProp::_internal_set_value_field(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_field_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSystemProp::_internal_mutable_value_field() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_field_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSystemProp::release_value_field() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.GetSystemProp.value_field)
  if (!_internal_has_value_field()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_field_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_field_.IsDefault()) {
    _impl_.value_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetSystemProp::set_allocated_value_field(std::string* value_field) {
  if (value_field != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_field_.SetAllocated(value_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_field_.IsDefault()) {
    _impl_.value_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.GetSystemProp.value_field)
}

// -------------------------------------------------------------------

// UpdateAppWindowSize

// required string package_name = 1;
inline bool UpdateAppWindowSize::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateAppWindowSize::has_package_name() const {
  return _internal_has_package_name();
}
inline void UpdateAppWindowSize::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateAppWindowSize::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateAppWindowSize::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.package_name)
}
inline std::string* UpdateAppWindowSize::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.package_name)
  return _s;
}
inline const std::string& UpdateAppWindowSize::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void UpdateAppWindowSize::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAppWindowSize::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateAppWindowSize::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateAppWindowSize::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.package_name)
}

// required int32 display_id = 2;
inline bool UpdateAppWindowSize::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateAppWindowSize::has_display_id() const {
  return _internal_has_display_id();
}
inline void UpdateAppWindowSize::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t UpdateAppWindowSize::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t UpdateAppWindowSize::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.display_id)
  return _internal_display_id();
}
inline void UpdateAppWindowSize::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.display_id_ = value;
}
inline void UpdateAppWindowSize::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.display_id)
}

// required int32 width = 3;
inline bool UpdateAppWindowSize::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateAppWindowSize::has_width() const {
  return _internal_has_width();
}
inline void UpdateAppWindowSize::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t UpdateAppWindowSize::_internal_width() const {
  return _impl_.width_;
}
inline int32_t UpdateAppWindowSize::width() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.width)
  return _internal_width();
}
inline void UpdateAppWindowSize::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.width_ = value;
}
inline void UpdateAppWindowSize::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.width)
}

// required int32 height = 4;
inline bool UpdateAppWindowSize::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpdateAppWindowSize::has_height() const {
  return _internal_has_height();
}
inline void UpdateAppWindowSize::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t UpdateAppWindowSize::_internal_height() const {
  return _impl_.height_;
}
inline int32_t UpdateAppWindowSize::height() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.height)
  return _internal_height();
}
inline void UpdateAppWindowSize::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.height_ = value;
}
inline void UpdateAppWindowSize::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdateAppWindowSize.height)
}

// -------------------------------------------------------------------

// SetProxy

// required bool open = 1;
inline bool SetProxy::_internal_has_open() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SetProxy::has_open() const {
  return _internal_has_open();
}
inline void SetProxy::clear_open() {
  _impl_.open_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SetProxy::_internal_open() const {
  return _impl_.open_;
}
inline bool SetProxy::open() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SetProxy.open)
  return _internal_open();
}
inline void SetProxy::_internal_set_open(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.open_ = value;
}
inline void SetProxy::set_open(bool value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SetProxy.open)
}

// optional string host = 2;
inline bool SetProxy::_internal_has_host() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetProxy::has_host() const {
  return _internal_has_host();
}
inline void SetProxy::clear_host() {
  _impl_.host_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetProxy::host() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SetProxy.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetProxy::set_host(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SetProxy.host)
}
inline std::string* SetProxy::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SetProxy.host)
  return _s;
}
inline const std::string& SetProxy::_internal_host() const {
  return _impl_.host_.Get();
}
inline void SetProxy::_internal_set_host(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* SetProxy::_internal_mutable_host() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.host_.Mutable(GetArenaForAllocation());
}
inline std::string* SetProxy::release_host() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SetProxy.host)
  if (!_internal_has_host()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.host_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetProxy::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SetProxy.host)
}

// optional int32 port = 3;
inline bool SetProxy::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SetProxy::has_port() const {
  return _internal_has_port();
}
inline void SetProxy::clear_port() {
  _impl_.port_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SetProxy::_internal_port() const {
  return _impl_.port_;
}
inline int32_t SetProxy::port() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SetProxy.port)
  return _internal_port();
}
inline void SetProxy::_internal_set_port(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.port_ = value;
}
inline void SetProxy::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SetProxy.port)
}

// optional string type = 4;
inline bool SetProxy::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetProxy::has_type() const {
  return _internal_has_type();
}
inline void SetProxy::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetProxy::type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SetProxy.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetProxy::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SetProxy.type)
}
inline std::string* SetProxy::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SetProxy.type)
  return _s;
}
inline const std::string& SetProxy::_internal_type() const {
  return _impl_.type_.Get();
}
inline void SetProxy::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* SetProxy::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* SetProxy::release_type() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SetProxy.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetProxy::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SetProxy.type)
}

// -------------------------------------------------------------------

// UpdateDisplaySize

// required int32 display_id = 1;
inline bool UpdateDisplaySize::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateDisplaySize::has_display_id() const {
  return _internal_has_display_id();
}
inline void UpdateDisplaySize::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t UpdateDisplaySize::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t UpdateDisplaySize::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdateDisplaySize.display_id)
  return _internal_display_id();
}
inline void UpdateDisplaySize::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.display_id_ = value;
}
inline void UpdateDisplaySize::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdateDisplaySize.display_id)
}

// required int32 width = 2;
inline bool UpdateDisplaySize::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateDisplaySize::has_width() const {
  return _internal_has_width();
}
inline void UpdateDisplaySize::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t UpdateDisplaySize::_internal_width() const {
  return _impl_.width_;
}
inline int32_t UpdateDisplaySize::width() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdateDisplaySize.width)
  return _internal_width();
}
inline void UpdateDisplaySize::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.width_ = value;
}
inline void UpdateDisplaySize::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdateDisplaySize.width)
}

// required int32 height = 3;
inline bool UpdateDisplaySize::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateDisplaySize::has_height() const {
  return _internal_has_height();
}
inline void UpdateDisplaySize::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t UpdateDisplaySize::_internal_height() const {
  return _impl_.height_;
}
inline int32_t UpdateDisplaySize::height() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdateDisplaySize.height)
  return _internal_height();
}
inline void UpdateDisplaySize::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_ = value;
}
inline void UpdateDisplaySize::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdateDisplaySize.height)
}

// -------------------------------------------------------------------

// AnswerCall

// required bool answer = 1;
inline bool AnswerCall::_internal_has_answer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AnswerCall::has_answer() const {
  return _internal_has_answer();
}
inline void AnswerCall::clear_answer() {
  _impl_.answer_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AnswerCall::_internal_answer() const {
  return _impl_.answer_;
}
inline bool AnswerCall::answer() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.AnswerCall.answer)
  return _internal_answer();
}
inline void AnswerCall::_internal_set_answer(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.answer_ = value;
}
inline void AnswerCall::set_answer(bool value) {
  _internal_set_answer(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.AnswerCall.answer)
}

// -------------------------------------------------------------------

// ContainerEnvBootStatus

// required bool status = 1;
inline bool ContainerEnvBootStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContainerEnvBootStatus::has_status() const {
  return _internal_has_status();
}
inline void ContainerEnvBootStatus::clear_status() {
  _impl_.status_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ContainerEnvBootStatus::_internal_status() const {
  return _impl_.status_;
}
inline bool ContainerEnvBootStatus::status() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus.status)
  return _internal_status();
}
inline void ContainerEnvBootStatus::_internal_set_status(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void ContainerEnvBootStatus::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus.status)
}

// optional string err_info = 2;
inline bool ContainerEnvBootStatus::_internal_has_err_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContainerEnvBootStatus::has_err_info() const {
  return _internal_has_err_info();
}
inline void ContainerEnvBootStatus::clear_err_info() {
  _impl_.err_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContainerEnvBootStatus::err_info() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus.err_info)
  return _internal_err_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContainerEnvBootStatus::set_err_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.err_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus.err_info)
}
inline std::string* ContainerEnvBootStatus::mutable_err_info() {
  std::string* _s = _internal_mutable_err_info();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus.err_info)
  return _s;
}
inline const std::string& ContainerEnvBootStatus::_internal_err_info() const {
  return _impl_.err_info_.Get();
}
inline void ContainerEnvBootStatus::_internal_set_err_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.err_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ContainerEnvBootStatus::_internal_mutable_err_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.err_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ContainerEnvBootStatus::release_err_info() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus.err_info)
  if (!_internal_has_err_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.err_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_info_.IsDefault()) {
    _impl_.err_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContainerEnvBootStatus::set_allocated_err_info(std::string* err_info) {
  if (err_info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.err_info_.SetAllocated(err_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_info_.IsDefault()) {
    _impl_.err_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus.err_info)
}

// -------------------------------------------------------------------

// ActionResult

// required bool result = 1;
inline bool ActionResult::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ActionResult::has_result() const {
  return _internal_has_result();
}
inline void ActionResult::clear_result() {
  _impl_.result_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ActionResult::_internal_result() const {
  return _impl_.result_;
}
inline bool ActionResult::result() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ActionResult.result)
  return _internal_result();
}
inline void ActionResult::_internal_set_result(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.result_ = value;
}
inline void ActionResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ActionResult.result)
}

// required string org_cmd = 2;
inline bool ActionResult::_internal_has_org_cmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionResult::has_org_cmd() const {
  return _internal_has_org_cmd();
}
inline void ActionResult::clear_org_cmd() {
  _impl_.org_cmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionResult::org_cmd() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ActionResult.org_cmd)
  return _internal_org_cmd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionResult::set_org_cmd(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.org_cmd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ActionResult.org_cmd)
}
inline std::string* ActionResult::mutable_org_cmd() {
  std::string* _s = _internal_mutable_org_cmd();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.ActionResult.org_cmd)
  return _s;
}
inline const std::string& ActionResult::_internal_org_cmd() const {
  return _impl_.org_cmd_.Get();
}
inline void ActionResult::_internal_set_org_cmd(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.org_cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionResult::_internal_mutable_org_cmd() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.org_cmd_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionResult::release_org_cmd() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.ActionResult.org_cmd)
  if (!_internal_has_org_cmd()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.org_cmd_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.org_cmd_.IsDefault()) {
    _impl_.org_cmd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionResult::set_allocated_org_cmd(std::string* org_cmd) {
  if (org_cmd != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.org_cmd_.SetAllocated(org_cmd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.org_cmd_.IsDefault()) {
    _impl_.org_cmd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.ActionResult.org_cmd)
}

// optional string err_info = 3;
inline bool ActionResult::_internal_has_err_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionResult::has_err_info() const {
  return _internal_has_err_info();
}
inline void ActionResult::clear_err_info() {
  _impl_.err_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActionResult::err_info() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ActionResult.err_info)
  return _internal_err_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionResult::set_err_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.err_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ActionResult.err_info)
}
inline std::string* ActionResult::mutable_err_info() {
  std::string* _s = _internal_mutable_err_info();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.ActionResult.err_info)
  return _s;
}
inline const std::string& ActionResult::_internal_err_info() const {
  return _impl_.err_info_.Get();
}
inline void ActionResult::_internal_set_err_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.err_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionResult::_internal_mutable_err_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.err_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionResult::release_err_info() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.ActionResult.err_info)
  if (!_internal_has_err_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.err_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_info_.IsDefault()) {
    _impl_.err_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionResult::set_allocated_err_info(std::string* err_info) {
  if (err_info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.err_info_.SetAllocated(err_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_info_.IsDefault()) {
    _impl_.err_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.ActionResult.err_info)
}

// -------------------------------------------------------------------

// EventInfo

// required int32 event_id = 1;
inline bool EventInfo::_internal_has_event_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EventInfo::has_event_id() const {
  return _internal_has_event_id();
}
inline void EventInfo::clear_event_id() {
  _impl_.event_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t EventInfo::_internal_event_id() const {
  return _impl_.event_id_;
}
inline int32_t EventInfo::event_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventInfo.event_id)
  return _internal_event_id();
}
inline void EventInfo::_internal_set_event_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.event_id_ = value;
}
inline void EventInfo::set_event_id(int32_t value) {
  _internal_set_event_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.EventInfo.event_id)
}

// optional string package_name = 2;
inline bool EventInfo::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EventInfo::has_package_name() const {
  return _internal_has_package_name();
}
inline void EventInfo::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EventInfo::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventInfo.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventInfo::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.EventInfo.package_name)
}
inline std::string* EventInfo::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventInfo.package_name)
  return _s;
}
inline const std::string& EventInfo::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void EventInfo::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* EventInfo::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* EventInfo::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventInfo.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EventInfo::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventInfo.package_name)
}

// -------------------------------------------------------------------

// InstalledAppItem

// required string app_name = 1;
inline bool InstalledAppItem::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstalledAppItem::has_app_name() const {
  return _internal_has_app_name();
}
inline void InstalledAppItem::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstalledAppItem::app_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledAppItem::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_name)
}
inline std::string* InstalledAppItem::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_name)
  return _s;
}
inline const std::string& InstalledAppItem::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void InstalledAppItem::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledAppItem::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledAppItem::release_app_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstalledAppItem::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_name)
}

// required string package_name = 2;
inline bool InstalledAppItem::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstalledAppItem::has_package_name() const {
  return _internal_has_package_name();
}
inline void InstalledAppItem::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstalledAppItem::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstalledAppItem.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledAppItem::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstalledAppItem.package_name)
}
inline std::string* InstalledAppItem::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InstalledAppItem.package_name)
  return _s;
}
inline const std::string& InstalledAppItem::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void InstalledAppItem::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledAppItem::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledAppItem::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InstalledAppItem.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstalledAppItem::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InstalledAppItem.package_name)
}

// required int64 version_code = 3;
inline bool InstalledAppItem::_internal_has_version_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InstalledAppItem::has_version_code() const {
  return _internal_has_version_code();
}
inline void InstalledAppItem::clear_version_code() {
  _impl_.version_code_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t InstalledAppItem::_internal_version_code() const {
  return _impl_.version_code_;
}
inline int64_t InstalledAppItem::version_code() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstalledAppItem.version_code)
  return _internal_version_code();
}
inline void InstalledAppItem::_internal_set_version_code(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.version_code_ = value;
}
inline void InstalledAppItem::set_version_code(int64_t value) {
  _internal_set_version_code(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstalledAppItem.version_code)
}

// required string version_name = 4;
inline bool InstalledAppItem::_internal_has_version_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InstalledAppItem::has_version_name() const {
  return _internal_has_version_name();
}
inline void InstalledAppItem::clear_version_name() {
  _impl_.version_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InstalledAppItem::version_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstalledAppItem.version_name)
  return _internal_version_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledAppItem::set_version_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.version_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstalledAppItem.version_name)
}
inline std::string* InstalledAppItem::mutable_version_name() {
  std::string* _s = _internal_mutable_version_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InstalledAppItem.version_name)
  return _s;
}
inline const std::string& InstalledAppItem::_internal_version_name() const {
  return _impl_.version_name_.Get();
}
inline void InstalledAppItem::_internal_set_version_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.version_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledAppItem::_internal_mutable_version_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.version_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledAppItem::release_version_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InstalledAppItem.version_name)
  if (!_internal_has_version_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.version_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_name_.IsDefault()) {
    _impl_.version_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstalledAppItem::set_allocated_version_name(std::string* version_name) {
  if (version_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.version_name_.SetAllocated(version_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_name_.IsDefault()) {
    _impl_.version_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InstalledAppItem.version_name)
}

// optional string app_info = 5;
inline bool InstalledAppItem::_internal_has_app_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InstalledAppItem::has_app_info() const {
  return _internal_has_app_info();
}
inline void InstalledAppItem::clear_app_info() {
  _impl_.app_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InstalledAppItem::app_info() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_info)
  return _internal_app_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstalledAppItem::set_app_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.app_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_info)
}
inline std::string* InstalledAppItem::mutable_app_info() {
  std::string* _s = _internal_mutable_app_info();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_info)
  return _s;
}
inline const std::string& InstalledAppItem::_internal_app_info() const {
  return _impl_.app_info_.Get();
}
inline void InstalledAppItem::_internal_set_app_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.app_info_.Set(value, GetArenaForAllocation());
}
inline std::string* InstalledAppItem::_internal_mutable_app_info() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.app_info_.Mutable(GetArenaForAllocation());
}
inline std::string* InstalledAppItem::release_app_info() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_info)
  if (!_internal_has_app_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.app_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_info_.IsDefault()) {
    _impl_.app_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InstalledAppItem::set_allocated_app_info(std::string* app_info) {
  if (app_info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.app_info_.SetAllocated(app_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_info_.IsDefault()) {
    _impl_.app_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InstalledAppItem.app_info)
}

// -------------------------------------------------------------------

// InstalledAppList

// repeated .cn.kylinos.kmre.kmrecore.InstalledAppItem item = 1;
inline int InstalledAppList::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int InstalledAppList::item_size() const {
  return _internal_item_size();
}
inline void InstalledAppList::clear_item() {
  _impl_.item_.Clear();
}
inline ::cn::kylinos::kmre::kmrecore::InstalledAppItem* InstalledAppList::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InstalledAppList.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::InstalledAppItem >*
InstalledAppList::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:cn.kylinos.kmre.kmrecore.InstalledAppList.item)
  return &_impl_.item_;
}
inline const ::cn::kylinos::kmre::kmrecore::InstalledAppItem& InstalledAppList::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::cn::kylinos::kmre::kmrecore::InstalledAppItem& InstalledAppList::item(int index) const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstalledAppList.item)
  return _internal_item(index);
}
inline ::cn::kylinos::kmre::kmrecore::InstalledAppItem* InstalledAppList::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::cn::kylinos::kmre::kmrecore::InstalledAppItem* InstalledAppList::add_item() {
  ::cn::kylinos::kmre::kmrecore::InstalledAppItem* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:cn.kylinos.kmre.kmrecore.InstalledAppList.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::InstalledAppItem >&
InstalledAppList::item() const {
  // @@protoc_insertion_point(field_list:cn.kylinos.kmre.kmrecore.InstalledAppList.item)
  return _impl_.item_;
}

// required int32 size = 2;
inline bool InstalledAppList::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstalledAppList::has_size() const {
  return _internal_has_size();
}
inline void InstalledAppList::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t InstalledAppList::_internal_size() const {
  return _impl_.size_;
}
inline int32_t InstalledAppList::size() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InstalledAppList.size)
  return _internal_size();
}
inline void InstalledAppList::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void InstalledAppList::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InstalledAppList.size)
}

// -------------------------------------------------------------------

// RunningAppItem

// required string app_name = 1;
inline bool RunningAppItem::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RunningAppItem::has_app_name() const {
  return _internal_has_app_name();
}
inline void RunningAppItem::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RunningAppItem::app_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RunningAppItem.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunningAppItem::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RunningAppItem.app_name)
}
inline std::string* RunningAppItem::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.RunningAppItem.app_name)
  return _s;
}
inline const std::string& RunningAppItem::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void RunningAppItem::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RunningAppItem::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RunningAppItem::release_app_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.RunningAppItem.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RunningAppItem::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.RunningAppItem.app_name)
}

// required string package_name = 2;
inline bool RunningAppItem::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RunningAppItem::has_package_name() const {
  return _internal_has_package_name();
}
inline void RunningAppItem::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RunningAppItem::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RunningAppItem.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunningAppItem::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RunningAppItem.package_name)
}
inline std::string* RunningAppItem::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.RunningAppItem.package_name)
  return _s;
}
inline const std::string& RunningAppItem::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void RunningAppItem::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RunningAppItem::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RunningAppItem::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.RunningAppItem.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RunningAppItem::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.RunningAppItem.package_name)
}

// -------------------------------------------------------------------

// RunningAppList

// repeated .cn.kylinos.kmre.kmrecore.RunningAppItem item = 1;
inline int RunningAppList::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int RunningAppList::item_size() const {
  return _internal_item_size();
}
inline void RunningAppList::clear_item() {
  _impl_.item_.Clear();
}
inline ::cn::kylinos::kmre::kmrecore::RunningAppItem* RunningAppList::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.RunningAppList.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::RunningAppItem >*
RunningAppList::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:cn.kylinos.kmre.kmrecore.RunningAppList.item)
  return &_impl_.item_;
}
inline const ::cn::kylinos::kmre::kmrecore::RunningAppItem& RunningAppList::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::cn::kylinos::kmre::kmrecore::RunningAppItem& RunningAppList::item(int index) const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RunningAppList.item)
  return _internal_item(index);
}
inline ::cn::kylinos::kmre::kmrecore::RunningAppItem* RunningAppList::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::cn::kylinos::kmre::kmrecore::RunningAppItem* RunningAppList::add_item() {
  ::cn::kylinos::kmre::kmrecore::RunningAppItem* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:cn.kylinos.kmre.kmrecore.RunningAppList.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::RunningAppItem >&
RunningAppList::item() const {
  // @@protoc_insertion_point(field_list:cn.kylinos.kmre.kmrecore.RunningAppList.item)
  return _impl_.item_;
}

// required int32 size = 2;
inline bool RunningAppList::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RunningAppList::has_size() const {
  return _internal_has_size();
}
inline void RunningAppList::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RunningAppList::_internal_size() const {
  return _impl_.size_;
}
inline int32_t RunningAppList::size() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.RunningAppList.size)
  return _internal_size();
}
inline void RunningAppList::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void RunningAppList::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.RunningAppList.size)
}

// -------------------------------------------------------------------

// Notification

// required string package_name = 1;
inline bool Notification::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Notification::has_package_name() const {
  return _internal_has_package_name();
}
inline void Notification::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Notification::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Notification.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Notification.package_name)
}
inline std::string* Notification::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.Notification.package_name)
  return _s;
}
inline const std::string& Notification::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void Notification::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.Notification.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Notification::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.Notification.package_name)
}

// required string app_name = 2;
inline bool Notification::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Notification::has_app_name() const {
  return _internal_has_app_name();
}
inline void Notification::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Notification::app_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Notification.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Notification.app_name)
}
inline std::string* Notification::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.Notification.app_name)
  return _s;
}
inline const std::string& Notification::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void Notification::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_app_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.Notification.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Notification::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.Notification.app_name)
}

// optional string text = 3;
inline bool Notification::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Notification::has_text() const {
  return _internal_has_text();
}
inline void Notification::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Notification::text() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Notification.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Notification.text)
}
inline std::string* Notification::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.Notification.text)
  return _s;
}
inline const std::string& Notification::_internal_text() const {
  return _impl_.text_.Get();
}
inline void Notification::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_text() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.Notification.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Notification::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.Notification.text)
}

// optional int32 display_id = 4;
inline bool Notification::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Notification::has_display_id() const {
  return _internal_has_display_id();
}
inline void Notification::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Notification::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t Notification::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Notification.display_id)
  return _internal_display_id();
}
inline void Notification::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.display_id_ = value;
}
inline void Notification::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Notification.display_id)
}

// optional bool hide = 5;
inline bool Notification::_internal_has_hide() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Notification::has_hide() const {
  return _internal_has_hide();
}
inline void Notification::clear_hide() {
  _impl_.hide_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Notification::_internal_hide() const {
  return _impl_.hide_;
}
inline bool Notification::hide() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Notification.hide)
  return _internal_hide();
}
inline void Notification::_internal_set_hide(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.hide_ = value;
}
inline void Notification::set_hide(bool value) {
  _internal_set_hide(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Notification.hide)
}

// optional bool incoming_call = 6;
inline bool Notification::_internal_has_incoming_call() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Notification::has_incoming_call() const {
  return _internal_has_incoming_call();
}
inline void Notification::clear_incoming_call() {
  _impl_.incoming_call_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Notification::_internal_incoming_call() const {
  return _impl_.incoming_call_;
}
inline bool Notification::incoming_call() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Notification.incoming_call)
  return _internal_incoming_call();
}
inline void Notification::_internal_set_incoming_call(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.incoming_call_ = value;
}
inline void Notification::set_incoming_call(bool value) {
  _internal_set_incoming_call(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Notification.incoming_call)
}

// optional string title = 7;
inline bool Notification::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Notification::has_title() const {
  return _internal_has_title();
}
inline void Notification::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Notification::title() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Notification.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Notification.title)
}
inline std::string* Notification::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.Notification.title)
  return _s;
}
inline const std::string& Notification::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Notification::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_title() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.Notification.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Notification::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.Notification.title)
}

// -------------------------------------------------------------------

// LaunchResult

// required string app_name = 1;
inline bool LaunchResult::_internal_has_app_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LaunchResult::has_app_name() const {
  return _internal_has_app_name();
}
inline void LaunchResult::clear_app_name() {
  _impl_.app_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LaunchResult::app_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.app_name)
  return _internal_app_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LaunchResult::set_app_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.app_name)
}
inline std::string* LaunchResult::mutable_app_name() {
  std::string* _s = _internal_mutable_app_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.LaunchResult.app_name)
  return _s;
}
inline const std::string& LaunchResult::_internal_app_name() const {
  return _impl_.app_name_.Get();
}
inline void LaunchResult::_internal_set_app_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LaunchResult::_internal_mutable_app_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LaunchResult::release_app_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.LaunchResult.app_name)
  if (!_internal_has_app_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LaunchResult::set_allocated_app_name(std::string* app_name) {
  if (app_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_name_.SetAllocated(app_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_name_.IsDefault()) {
    _impl_.app_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.LaunchResult.app_name)
}

// required string package_name = 2;
inline bool LaunchResult::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LaunchResult::has_package_name() const {
  return _internal_has_package_name();
}
inline void LaunchResult::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LaunchResult::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LaunchResult::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.package_name)
}
inline std::string* LaunchResult::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.LaunchResult.package_name)
  return _s;
}
inline const std::string& LaunchResult::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void LaunchResult::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LaunchResult::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LaunchResult::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.LaunchResult.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LaunchResult::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.LaunchResult.package_name)
}

// required bool result = 3;
inline bool LaunchResult::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LaunchResult::has_result() const {
  return _internal_has_result();
}
inline void LaunchResult::clear_result() {
  _impl_.result_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool LaunchResult::_internal_result() const {
  return _impl_.result_;
}
inline bool LaunchResult::result() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.result)
  return _internal_result();
}
inline void LaunchResult::_internal_set_result(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.result_ = value;
}
inline void LaunchResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.result)
}

// required int32 display_id = 4;
inline bool LaunchResult::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LaunchResult::has_display_id() const {
  return _internal_has_display_id();
}
inline void LaunchResult::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t LaunchResult::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t LaunchResult::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.display_id)
  return _internal_display_id();
}
inline void LaunchResult::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.display_id_ = value;
}
inline void LaunchResult::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.display_id)
}

// required int32 width = 5;
inline bool LaunchResult::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LaunchResult::has_width() const {
  return _internal_has_width();
}
inline void LaunchResult::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t LaunchResult::_internal_width() const {
  return _impl_.width_;
}
inline int32_t LaunchResult::width() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.width)
  return _internal_width();
}
inline void LaunchResult::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.width_ = value;
}
inline void LaunchResult::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.width)
}

// required int32 height = 6;
inline bool LaunchResult::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LaunchResult::has_height() const {
  return _internal_has_height();
}
inline void LaunchResult::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t LaunchResult::_internal_height() const {
  return _impl_.height_;
}
inline int32_t LaunchResult::height() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.height)
  return _internal_height();
}
inline void LaunchResult::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.height_ = value;
}
inline void LaunchResult::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.height)
}

// required int32 density = 7;
inline bool LaunchResult::_internal_has_density() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LaunchResult::has_density() const {
  return _internal_has_density();
}
inline void LaunchResult::clear_density() {
  _impl_.density_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t LaunchResult::_internal_density() const {
  return _impl_.density_;
}
inline int32_t LaunchResult::density() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.density)
  return _internal_density();
}
inline void LaunchResult::_internal_set_density(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.density_ = value;
}
inline void LaunchResult::set_density(int32_t value) {
  _internal_set_density(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.density)
}

// required bool fullscreen = 8;
inline bool LaunchResult::_internal_has_fullscreen() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LaunchResult::has_fullscreen() const {
  return _internal_has_fullscreen();
}
inline void LaunchResult::clear_fullscreen() {
  _impl_.fullscreen_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool LaunchResult::_internal_fullscreen() const {
  return _impl_.fullscreen_;
}
inline bool LaunchResult::fullscreen() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.fullscreen)
  return _internal_fullscreen();
}
inline void LaunchResult::_internal_set_fullscreen(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.fullscreen_ = value;
}
inline void LaunchResult::set_fullscreen(bool value) {
  _internal_set_fullscreen(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.fullscreen)
}

// optional bool exists = 9;
inline bool LaunchResult::_internal_has_exists() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LaunchResult::has_exists() const {
  return _internal_has_exists();
}
inline void LaunchResult::clear_exists() {
  _impl_.exists_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool LaunchResult::_internal_exists() const {
  return _impl_.exists_;
}
inline bool LaunchResult::exists() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.exists)
  return _internal_exists();
}
inline void LaunchResult::_internal_set_exists(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.exists_ = value;
}
inline void LaunchResult::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.exists)
}

// optional bool app_resumed = 10;
inline bool LaunchResult::_internal_has_app_resumed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LaunchResult::has_app_resumed() const {
  return _internal_has_app_resumed();
}
inline void LaunchResult::clear_app_resumed() {
  _impl_.app_resumed_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool LaunchResult::_internal_app_resumed() const {
  return _impl_.app_resumed_;
}
inline bool LaunchResult::app_resumed() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LaunchResult.app_resumed)
  return _internal_app_resumed();
}
inline void LaunchResult::_internal_set_app_resumed(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.app_resumed_ = value;
}
inline void LaunchResult::set_app_resumed(bool value) {
  _internal_set_app_resumed(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LaunchResult.app_resumed)
}

// -------------------------------------------------------------------

// CloseResult

// required string package_name = 1;
inline bool CloseResult::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CloseResult::has_package_name() const {
  return _internal_has_package_name();
}
inline void CloseResult::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CloseResult::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.CloseResult.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloseResult::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.CloseResult.package_name)
}
inline std::string* CloseResult::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.CloseResult.package_name)
  return _s;
}
inline const std::string& CloseResult::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void CloseResult::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CloseResult::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CloseResult::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.CloseResult.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CloseResult::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.CloseResult.package_name)
}

// required bool result = 2;
inline bool CloseResult::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CloseResult::has_result() const {
  return _internal_has_result();
}
inline void CloseResult::clear_result() {
  _impl_.result_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CloseResult::_internal_result() const {
  return _impl_.result_;
}
inline bool CloseResult::result() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.CloseResult.result)
  return _internal_result();
}
inline void CloseResult::_internal_set_result(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_ = value;
}
inline void CloseResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.CloseResult.result)
}

// -------------------------------------------------------------------

// VirtualScreenFocusResult

// required int32 display_id = 1;
inline bool VirtualScreenFocusResult::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualScreenFocusResult::has_display_id() const {
  return _internal_has_display_id();
}
inline void VirtualScreenFocusResult::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VirtualScreenFocusResult::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t VirtualScreenFocusResult::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult.display_id)
  return _internal_display_id();
}
inline void VirtualScreenFocusResult::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.display_id_ = value;
}
inline void VirtualScreenFocusResult::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult.display_id)
}

// required bool result = 2;
inline bool VirtualScreenFocusResult::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VirtualScreenFocusResult::has_result() const {
  return _internal_has_result();
}
inline void VirtualScreenFocusResult::clear_result() {
  _impl_.result_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool VirtualScreenFocusResult::_internal_result() const {
  return _impl_.result_;
}
inline bool VirtualScreenFocusResult::result() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult.result)
  return _internal_result();
}
inline void VirtualScreenFocusResult::_internal_set_result(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_ = value;
}
inline void VirtualScreenFocusResult::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult.result)
}

// -------------------------------------------------------------------

// InputMethodRequest

// required int32 display_id = 1;
inline bool InputMethodRequest::_internal_has_display_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InputMethodRequest::has_display_id() const {
  return _internal_has_display_id();
}
inline void InputMethodRequest::clear_display_id() {
  _impl_.display_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t InputMethodRequest::_internal_display_id() const {
  return _impl_.display_id_;
}
inline int32_t InputMethodRequest::display_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InputMethodRequest.display_id)
  return _internal_display_id();
}
inline void InputMethodRequest::_internal_set_display_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.display_id_ = value;
}
inline void InputMethodRequest::set_display_id(int32_t value) {
  _internal_set_display_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InputMethodRequest.display_id)
}

// required string package_name = 2;
inline bool InputMethodRequest::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InputMethodRequest::has_package_name() const {
  return _internal_has_package_name();
}
inline void InputMethodRequest::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputMethodRequest::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InputMethodRequest.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputMethodRequest::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InputMethodRequest.package_name)
}
inline std::string* InputMethodRequest::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.InputMethodRequest.package_name)
  return _s;
}
inline const std::string& InputMethodRequest::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void InputMethodRequest::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InputMethodRequest::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InputMethodRequest::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.InputMethodRequest.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InputMethodRequest::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.InputMethodRequest.package_name)
}

// required bool ret = 3;
inline bool InputMethodRequest::_internal_has_ret() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InputMethodRequest::has_ret() const {
  return _internal_has_ret();
}
inline void InputMethodRequest::clear_ret() {
  _impl_.ret_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool InputMethodRequest::_internal_ret() const {
  return _impl_.ret_;
}
inline bool InputMethodRequest::ret() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InputMethodRequest.ret)
  return _internal_ret();
}
inline void InputMethodRequest::_internal_set_ret(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ret_ = value;
}
inline void InputMethodRequest::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InputMethodRequest.ret)
}

// optional int32 x_pos = 4;
inline bool InputMethodRequest::_internal_has_x_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InputMethodRequest::has_x_pos() const {
  return _internal_has_x_pos();
}
inline void InputMethodRequest::clear_x_pos() {
  _impl_.x_pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t InputMethodRequest::_internal_x_pos() const {
  return _impl_.x_pos_;
}
inline int32_t InputMethodRequest::x_pos() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InputMethodRequest.x_pos)
  return _internal_x_pos();
}
inline void InputMethodRequest::_internal_set_x_pos(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.x_pos_ = value;
}
inline void InputMethodRequest::set_x_pos(int32_t value) {
  _internal_set_x_pos(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InputMethodRequest.x_pos)
}

// optional int32 y_pos = 5;
inline bool InputMethodRequest::_internal_has_y_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InputMethodRequest::has_y_pos() const {
  return _internal_has_y_pos();
}
inline void InputMethodRequest::clear_y_pos() {
  _impl_.y_pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t InputMethodRequest::_internal_y_pos() const {
  return _impl_.y_pos_;
}
inline int32_t InputMethodRequest::y_pos() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.InputMethodRequest.y_pos)
  return _internal_y_pos();
}
inline void InputMethodRequest::_internal_set_y_pos(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.y_pos_ = value;
}
inline void InputMethodRequest::set_y_pos(int32_t value) {
  _internal_set_y_pos(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.InputMethodRequest.y_pos)
}

// -------------------------------------------------------------------

// SingleFile

// required string data = 1;
inline bool SingleFile::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SingleFile::has_data() const {
  return _internal_has_data();
}
inline void SingleFile::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SingleFile::data() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SingleFile.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleFile::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SingleFile.data)
}
inline std::string* SingleFile::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SingleFile.data)
  return _s;
}
inline const std::string& SingleFile::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SingleFile::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleFile::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SingleFile::release_data() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SingleFile.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SingleFile::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SingleFile.data)
}

// required string mime_type = 2;
inline bool SingleFile::_internal_has_mime_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SingleFile::has_mime_type() const {
  return _internal_has_mime_type();
}
inline void SingleFile::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SingleFile::mime_type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SingleFile.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleFile::set_mime_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SingleFile.mime_type)
}
inline std::string* SingleFile::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SingleFile.mime_type)
  return _s;
}
inline const std::string& SingleFile::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void SingleFile::_internal_set_mime_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleFile::_internal_mutable_mime_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SingleFile::release_mime_type() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SingleFile.mime_type)
  if (!_internal_has_mime_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SingleFile::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SingleFile.mime_type)
}

// optional string package_name = 3;
inline bool SingleFile::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SingleFile::has_package_name() const {
  return _internal_has_package_name();
}
inline void SingleFile::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SingleFile::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SingleFile.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SingleFile::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SingleFile.package_name)
}
inline std::string* SingleFile::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SingleFile.package_name)
  return _s;
}
inline const std::string& SingleFile::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void SingleFile::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleFile::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SingleFile::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SingleFile.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SingleFile::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SingleFile.package_name)
}

// -------------------------------------------------------------------

// FilesList

// required int32 type = 1;
inline bool FilesList::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FilesList::has_type() const {
  return _internal_has_type();
}
inline void FilesList::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t FilesList::_internal_type() const {
  return _impl_.type_;
}
inline int32_t FilesList::type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.FilesList.type)
  return _internal_type();
}
inline void FilesList::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void FilesList::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.FilesList.type)
}

// repeated .cn.kylinos.kmre.kmrecore.SingleFile item = 2;
inline int FilesList::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int FilesList::item_size() const {
  return _internal_item_size();
}
inline void FilesList::clear_item() {
  _impl_.item_.Clear();
}
inline ::cn::kylinos::kmre::kmrecore::SingleFile* FilesList::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.FilesList.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::SingleFile >*
FilesList::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:cn.kylinos.kmre.kmrecore.FilesList.item)
  return &_impl_.item_;
}
inline const ::cn::kylinos::kmre::kmrecore::SingleFile& FilesList::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::cn::kylinos::kmre::kmrecore::SingleFile& FilesList::item(int index) const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.FilesList.item)
  return _internal_item(index);
}
inline ::cn::kylinos::kmre::kmrecore::SingleFile* FilesList::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::cn::kylinos::kmre::kmrecore::SingleFile* FilesList::add_item() {
  ::cn::kylinos::kmre::kmrecore::SingleFile* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:cn.kylinos.kmre.kmrecore.FilesList.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::SingleFile >&
FilesList::item() const {
  // @@protoc_insertion_point(field_list:cn.kylinos.kmre.kmrecore.FilesList.item)
  return _impl_.item_;
}

// required int32 size = 3;
inline bool FilesList::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FilesList::has_size() const {
  return _internal_has_size();
}
inline void FilesList::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t FilesList::_internal_size() const {
  return _impl_.size_;
}
inline int32_t FilesList::size() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.FilesList.size)
  return _internal_size();
}
inline void FilesList::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void FilesList::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.FilesList.size)
}

// -------------------------------------------------------------------

// MediaPlayStatus

// required bool result = 1;
inline bool MediaPlayStatus::_internal_has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MediaPlayStatus::has_result() const {
  return _internal_has_result();
}
inline void MediaPlayStatus::clear_result() {
  _impl_.result_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MediaPlayStatus::_internal_result() const {
  return _impl_.result_;
}
inline bool MediaPlayStatus::result() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.MediaPlayStatus.result)
  return _internal_result();
}
inline void MediaPlayStatus::_internal_set_result(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.result_ = value;
}
inline void MediaPlayStatus::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.MediaPlayStatus.result)
}

// -------------------------------------------------------------------

// AppMultiplier

// required string package_name = 1;
inline bool AppMultiplier::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppMultiplier::has_package_name() const {
  return _internal_has_package_name();
}
inline void AppMultiplier::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppMultiplier::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.AppMultiplier.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppMultiplier::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.AppMultiplier.package_name)
}
inline std::string* AppMultiplier::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.AppMultiplier.package_name)
  return _s;
}
inline const std::string& AppMultiplier::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void AppMultiplier::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AppMultiplier::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AppMultiplier::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.AppMultiplier.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppMultiplier::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.AppMultiplier.package_name)
}

// required int32 multiplier = 2;
inline bool AppMultiplier::_internal_has_multiplier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AppMultiplier::has_multiplier() const {
  return _internal_has_multiplier();
}
inline void AppMultiplier::clear_multiplier() {
  _impl_.multiplier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t AppMultiplier::_internal_multiplier() const {
  return _impl_.multiplier_;
}
inline int32_t AppMultiplier::multiplier() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.AppMultiplier.multiplier)
  return _internal_multiplier();
}
inline void AppMultiplier::_internal_set_multiplier(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.multiplier_ = value;
}
inline void AppMultiplier::set_multiplier(int32_t value) {
  _internal_set_multiplier(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.AppMultiplier.multiplier)
}

// optional string info = 3;
inline bool AppMultiplier::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppMultiplier::has_info() const {
  return _internal_has_info();
}
inline void AppMultiplier::clear_info() {
  _impl_.info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppMultiplier::info() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.AppMultiplier.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppMultiplier::set_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.AppMultiplier.info)
}
inline std::string* AppMultiplier::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.AppMultiplier.info)
  return _s;
}
inline const std::string& AppMultiplier::_internal_info() const {
  return _impl_.info_.Get();
}
inline void AppMultiplier::_internal_set_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* AppMultiplier::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.info_.Mutable(GetArenaForAllocation());
}
inline std::string* AppMultiplier::release_info() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.AppMultiplier.info)
  if (!_internal_has_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppMultiplier::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_.SetAllocated(info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.AppMultiplier.info)
}

// -------------------------------------------------------------------

// AppMultiplierList

// repeated .cn.kylinos.kmre.kmrecore.AppMultiplier item = 1;
inline int AppMultiplierList::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int AppMultiplierList::item_size() const {
  return _internal_item_size();
}
inline void AppMultiplierList::clear_item() {
  _impl_.item_.Clear();
}
inline ::cn::kylinos::kmre::kmrecore::AppMultiplier* AppMultiplierList::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.AppMultiplierList.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::AppMultiplier >*
AppMultiplierList::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:cn.kylinos.kmre.kmrecore.AppMultiplierList.item)
  return &_impl_.item_;
}
inline const ::cn::kylinos::kmre::kmrecore::AppMultiplier& AppMultiplierList::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::cn::kylinos::kmre::kmrecore::AppMultiplier& AppMultiplierList::item(int index) const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.AppMultiplierList.item)
  return _internal_item(index);
}
inline ::cn::kylinos::kmre::kmrecore::AppMultiplier* AppMultiplierList::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::cn::kylinos::kmre::kmrecore::AppMultiplier* AppMultiplierList::add_item() {
  ::cn::kylinos::kmre::kmrecore::AppMultiplier* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:cn.kylinos.kmre.kmrecore.AppMultiplierList.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::AppMultiplier >&
AppMultiplierList::item() const {
  // @@protoc_insertion_point(field_list:cn.kylinos.kmre.kmrecore.AppMultiplierList.item)
  return _impl_.item_;
}

// required int32 size = 2;
inline bool AppMultiplierList::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppMultiplierList::has_size() const {
  return _internal_has_size();
}
inline void AppMultiplierList::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t AppMultiplierList::_internal_size() const {
  return _impl_.size_;
}
inline int32_t AppMultiplierList::size() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.AppMultiplierList.size)
  return _internal_size();
}
inline void AppMultiplierList::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void AppMultiplierList::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.AppMultiplierList.size)
}

// -------------------------------------------------------------------

// Info

// required string package_name = 1;
inline bool Info::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Info::has_package_name() const {
  return _internal_has_package_name();
}
inline void Info::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Info::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Info.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Info.package_name)
}
inline std::string* Info::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.Info.package_name)
  return _s;
}
inline const std::string& Info::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void Info::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.Info.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Info::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.Info.package_name)
}

// optional int32 value1 = 2;
inline bool Info::_internal_has_value1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Info::has_value1() const {
  return _internal_has_value1();
}
inline void Info::clear_value1() {
  _impl_.value1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Info::_internal_value1() const {
  return _impl_.value1_;
}
inline int32_t Info::value1() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Info.value1)
  return _internal_value1();
}
inline void Info::_internal_set_value1(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.value1_ = value;
}
inline void Info::set_value1(int32_t value) {
  _internal_set_value1(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Info.value1)
}

// optional int32 value2 = 3;
inline bool Info::_internal_has_value2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Info::has_value2() const {
  return _internal_has_value2();
}
inline void Info::clear_value2() {
  _impl_.value2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Info::_internal_value2() const {
  return _impl_.value2_;
}
inline int32_t Info::value2() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Info.value2)
  return _internal_value2();
}
inline void Info::_internal_set_value2(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.value2_ = value;
}
inline void Info::set_value2(int32_t value) {
  _internal_set_value2(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Info.value2)
}

// optional string value3 = 4;
inline bool Info::_internal_has_value3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Info::has_value3() const {
  return _internal_has_value3();
}
inline void Info::clear_value3() {
  _impl_.value3_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Info::value3() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Info.value3)
  return _internal_value3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_value3(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Info.value3)
}
inline std::string* Info::mutable_value3() {
  std::string* _s = _internal_mutable_value3();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.Info.value3)
  return _s;
}
inline const std::string& Info::_internal_value3() const {
  return _impl_.value3_.Get();
}
inline void Info::_internal_set_value3(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value3_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_value3() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value3_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_value3() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.Info.value3)
  if (!_internal_has_value3()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value3_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value3_.IsDefault()) {
    _impl_.value3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Info::set_allocated_value3(std::string* value3) {
  if (value3 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value3_.SetAllocated(value3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value3_.IsDefault()) {
    _impl_.value3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.Info.value3)
}

// optional string value4 = 5;
inline bool Info::_internal_has_value4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Info::has_value4() const {
  return _internal_has_value4();
}
inline void Info::clear_value4() {
  _impl_.value4_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Info::value4() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.Info.value4)
  return _internal_value4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_value4(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.value4_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.Info.value4)
}
inline std::string* Info::mutable_value4() {
  std::string* _s = _internal_mutable_value4();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.Info.value4)
  return _s;
}
inline const std::string& Info::_internal_value4() const {
  return _impl_.value4_.Get();
}
inline void Info::_internal_set_value4(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.value4_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_value4() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.value4_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_value4() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.Info.value4)
  if (!_internal_has_value4()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.value4_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value4_.IsDefault()) {
    _impl_.value4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Info::set_allocated_value4(std::string* value4) {
  if (value4 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.value4_.SetAllocated(value4, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value4_.IsDefault()) {
    _impl_.value4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.Info.value4)
}

// -------------------------------------------------------------------

// GetInfoList

// repeated .cn.kylinos.kmre.kmrecore.Info item = 1;
inline int GetInfoList::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int GetInfoList::item_size() const {
  return _internal_item_size();
}
inline void GetInfoList::clear_item() {
  _impl_.item_.Clear();
}
inline ::cn::kylinos::kmre::kmrecore::Info* GetInfoList::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.GetInfoList.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::Info >*
GetInfoList::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:cn.kylinos.kmre.kmrecore.GetInfoList.item)
  return &_impl_.item_;
}
inline const ::cn::kylinos::kmre::kmrecore::Info& GetInfoList::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::cn::kylinos::kmre::kmrecore::Info& GetInfoList::item(int index) const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.GetInfoList.item)
  return _internal_item(index);
}
inline ::cn::kylinos::kmre::kmrecore::Info* GetInfoList::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::cn::kylinos::kmre::kmrecore::Info* GetInfoList::add_item() {
  ::cn::kylinos::kmre::kmrecore::Info* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:cn.kylinos.kmre.kmrecore.GetInfoList.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cn::kylinos::kmre::kmrecore::Info >&
GetInfoList::item() const {
  // @@protoc_insertion_point(field_list:cn.kylinos.kmre.kmrecore.GetInfoList.item)
  return _impl_.item_;
}

// required string type = 2;
inline bool GetInfoList::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetInfoList::has_type() const {
  return _internal_has_type();
}
inline void GetInfoList::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetInfoList::type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.GetInfoList.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInfoList::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.GetInfoList.type)
}
inline std::string* GetInfoList::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.GetInfoList.type)
  return _s;
}
inline const std::string& GetInfoList::_internal_type() const {
  return _impl_.type_.Get();
}
inline void GetInfoList::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInfoList::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInfoList::release_type() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.GetInfoList.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetInfoList::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.GetInfoList.type)
}

// required int32 size = 3;
inline bool GetInfoList::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetInfoList::has_size() const {
  return _internal_has_size();
}
inline void GetInfoList::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t GetInfoList::_internal_size() const {
  return _impl_.size_;
}
inline int32_t GetInfoList::size() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.GetInfoList.size)
  return _internal_size();
}
inline void GetInfoList::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void GetInfoList::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.GetInfoList.size)
}

// -------------------------------------------------------------------

// ResponseInfo

// required int32 event_id = 1;
inline bool ResponseInfo::_internal_has_event_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResponseInfo::has_event_id() const {
  return _internal_has_event_id();
}
inline void ResponseInfo::clear_event_id() {
  _impl_.event_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t ResponseInfo::_internal_event_id() const {
  return _impl_.event_id_;
}
inline int32_t ResponseInfo::event_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ResponseInfo.event_id)
  return _internal_event_id();
}
inline void ResponseInfo::_internal_set_event_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.event_id_ = value;
}
inline void ResponseInfo::set_event_id(int32_t value) {
  _internal_set_event_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ResponseInfo.event_id)
}

// required string package_name = 2;
inline bool ResponseInfo::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseInfo::has_package_name() const {
  return _internal_has_package_name();
}
inline void ResponseInfo::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseInfo::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ResponseInfo.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseInfo::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ResponseInfo.package_name)
}
inline std::string* ResponseInfo::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.ResponseInfo.package_name)
  return _s;
}
inline const std::string& ResponseInfo::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void ResponseInfo::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.ResponseInfo.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseInfo::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.ResponseInfo.package_name)
}

// required string category = 3;
inline bool ResponseInfo::_internal_has_category() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseInfo::has_category() const {
  return _internal_has_category();
}
inline void ResponseInfo::clear_category() {
  _impl_.category_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseInfo::category() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ResponseInfo.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseInfo::set_category(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ResponseInfo.category)
}
inline std::string* ResponseInfo::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.ResponseInfo.category)
  return _s;
}
inline const std::string& ResponseInfo::_internal_category() const {
  return _impl_.category_.Get();
}
inline void ResponseInfo::_internal_set_category(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_category() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_category() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.ResponseInfo.category)
  if (!_internal_has_category()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.category_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseInfo::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.ResponseInfo.category)
}

// required int32 ret = 4;
inline bool ResponseInfo::_internal_has_ret() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ResponseInfo::has_ret() const {
  return _internal_has_ret();
}
inline void ResponseInfo::clear_ret() {
  _impl_.ret_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t ResponseInfo::_internal_ret() const {
  return _impl_.ret_;
}
inline int32_t ResponseInfo::ret() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ResponseInfo.ret)
  return _internal_ret();
}
inline void ResponseInfo::_internal_set_ret(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ret_ = value;
}
inline void ResponseInfo::set_ret(int32_t value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ResponseInfo.ret)
}

// optional string info = 5;
inline bool ResponseInfo::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponseInfo::has_info() const {
  return _internal_has_info();
}
inline void ResponseInfo::clear_info() {
  _impl_.info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ResponseInfo::info() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.ResponseInfo.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseInfo::set_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.ResponseInfo.info)
}
inline std::string* ResponseInfo::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.ResponseInfo.info)
  return _s;
}
inline const std::string& ResponseInfo::_internal_info() const {
  return _impl_.info_.Get();
}
inline void ResponseInfo::_internal_set_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.info_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_info() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.ResponseInfo.info)
  if (!_internal_has_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseInfo::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.info_.SetAllocated(info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.ResponseInfo.info)
}

// -------------------------------------------------------------------

// MultiplierSwitch

// required int32 event_id = 1;
inline bool MultiplierSwitch::_internal_has_event_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MultiplierSwitch::has_event_id() const {
  return _internal_has_event_id();
}
inline void MultiplierSwitch::clear_event_id() {
  _impl_.event_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t MultiplierSwitch::_internal_event_id() const {
  return _impl_.event_id_;
}
inline int32_t MultiplierSwitch::event_id() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.MultiplierSwitch.event_id)
  return _internal_event_id();
}
inline void MultiplierSwitch::_internal_set_event_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.event_id_ = value;
}
inline void MultiplierSwitch::set_event_id(int32_t value) {
  _internal_set_event_id(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.MultiplierSwitch.event_id)
}

// required string package_name = 2;
inline bool MultiplierSwitch::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MultiplierSwitch::has_package_name() const {
  return _internal_has_package_name();
}
inline void MultiplierSwitch::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MultiplierSwitch::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.MultiplierSwitch.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiplierSwitch::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.MultiplierSwitch.package_name)
}
inline std::string* MultiplierSwitch::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.MultiplierSwitch.package_name)
  return _s;
}
inline const std::string& MultiplierSwitch::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void MultiplierSwitch::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MultiplierSwitch::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MultiplierSwitch::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.MultiplierSwitch.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MultiplierSwitch::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.MultiplierSwitch.package_name)
}

// required bool enable = 3;
inline bool MultiplierSwitch::_internal_has_enable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MultiplierSwitch::has_enable() const {
  return _internal_has_enable();
}
inline void MultiplierSwitch::clear_enable() {
  _impl_.enable_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MultiplierSwitch::_internal_enable() const {
  return _impl_.enable_;
}
inline bool MultiplierSwitch::enable() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.MultiplierSwitch.enable)
  return _internal_enable();
}
inline void MultiplierSwitch::_internal_set_enable(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.enable_ = value;
}
inline void MultiplierSwitch::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.MultiplierSwitch.enable)
}

// -------------------------------------------------------------------

// LinkOpen

// required string url = 1;
inline bool LinkOpen::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinkOpen::has_url() const {
  return _internal_has_url();
}
inline void LinkOpen::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LinkOpen::url() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.LinkOpen.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinkOpen::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.LinkOpen.url)
}
inline std::string* LinkOpen::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.LinkOpen.url)
  return _s;
}
inline const std::string& LinkOpen::_internal_url() const {
  return _impl_.url_.Get();
}
inline void LinkOpen::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* LinkOpen::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* LinkOpen::release_url() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.LinkOpen.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LinkOpen::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.LinkOpen.url)
}

// -------------------------------------------------------------------

// UpdatePackageStatus

// required string package_name = 1;
inline bool UpdatePackageStatus::_internal_has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdatePackageStatus::has_package_name() const {
  return _internal_has_package_name();
}
inline void UpdatePackageStatus::clear_package_name() {
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdatePackageStatus::package_name() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.package_name)
  return _internal_package_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePackageStatus::set_package_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.package_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.package_name)
}
inline std::string* UpdatePackageStatus::mutable_package_name() {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.package_name)
  return _s;
}
inline const std::string& UpdatePackageStatus::_internal_package_name() const {
  return _impl_.package_name_.Get();
}
inline void UpdatePackageStatus::_internal_set_package_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdatePackageStatus::_internal_mutable_package_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdatePackageStatus::release_package_name() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.package_name)
  if (!_internal_has_package_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.package_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdatePackageStatus::set_allocated_package_name(std::string* package_name) {
  if (package_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(package_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.package_name)
}

// required int32 status = 2;
inline bool UpdatePackageStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdatePackageStatus::has_status() const {
  return _internal_has_status();
}
inline void UpdatePackageStatus::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t UpdatePackageStatus::_internal_status() const {
  return _impl_.status_;
}
inline int32_t UpdatePackageStatus::status() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.status)
  return _internal_status();
}
inline void UpdatePackageStatus::_internal_set_status(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void UpdatePackageStatus::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.status)
}

// optional int32 type = 3;
inline bool UpdatePackageStatus::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdatePackageStatus::has_type() const {
  return _internal_has_type();
}
inline void UpdatePackageStatus::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t UpdatePackageStatus::_internal_type() const {
  return _impl_.type_;
}
inline int32_t UpdatePackageStatus::type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.type)
  return _internal_type();
}
inline void UpdatePackageStatus::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void UpdatePackageStatus::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.UpdatePackageStatus.type)
}

// -------------------------------------------------------------------

// SendSystemProp

// required int32 event_type = 1;
inline bool SendSystemProp::_internal_has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SendSystemProp::has_event_type() const {
  return _internal_has_event_type();
}
inline void SendSystemProp::clear_event_type() {
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SendSystemProp::_internal_event_type() const {
  return _impl_.event_type_;
}
inline int32_t SendSystemProp::event_type() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SendSystemProp.event_type)
  return _internal_event_type();
}
inline void SendSystemProp::_internal_set_event_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.event_type_ = value;
}
inline void SendSystemProp::set_event_type(int32_t value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SendSystemProp.event_type)
}

// required string value_field = 2;
inline bool SendSystemProp::_internal_has_value_field() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendSystemProp::has_value_field() const {
  return _internal_has_value_field();
}
inline void SendSystemProp::clear_value_field() {
  _impl_.value_field_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendSystemProp::value_field() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SendSystemProp.value_field)
  return _internal_value_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendSystemProp::set_value_field(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SendSystemProp.value_field)
}
inline std::string* SendSystemProp::mutable_value_field() {
  std::string* _s = _internal_mutable_value_field();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SendSystemProp.value_field)
  return _s;
}
inline const std::string& SendSystemProp::_internal_value_field() const {
  return _impl_.value_field_.Get();
}
inline void SendSystemProp::_internal_set_value_field(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_field_.Set(value, GetArenaForAllocation());
}
inline std::string* SendSystemProp::_internal_mutable_value_field() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_field_.Mutable(GetArenaForAllocation());
}
inline std::string* SendSystemProp::release_value_field() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SendSystemProp.value_field)
  if (!_internal_has_value_field()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_field_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_field_.IsDefault()) {
    _impl_.value_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendSystemProp::set_allocated_value_field(std::string* value_field) {
  if (value_field != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_field_.SetAllocated(value_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_field_.IsDefault()) {
    _impl_.value_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SendSystemProp.value_field)
}

// required string value = 3;
inline bool SendSystemProp::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SendSystemProp::has_value() const {
  return _internal_has_value();
}
inline void SendSystemProp::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SendSystemProp::value() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.SendSystemProp.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendSystemProp::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cn.kylinos.kmre.kmrecore.SendSystemProp.value)
}
inline std::string* SendSystemProp::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.SendSystemProp.value)
  return _s;
}
inline const std::string& SendSystemProp::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SendSystemProp::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SendSystemProp::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SendSystemProp::release_value() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.SendSystemProp.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendSystemProp::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.SendSystemProp.value)
}

// -------------------------------------------------------------------

// EventSequence

// optional .cn.kylinos.kmre.kmrecore.Notification notification = 1;
inline bool EventSequence::_internal_has_notification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.notification_ != nullptr);
  return value;
}
inline bool EventSequence::has_notification() const {
  return _internal_has_notification();
}
inline void EventSequence::clear_notification() {
  if (_impl_.notification_ != nullptr) _impl_.notification_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cn::kylinos::kmre::kmrecore::Notification& EventSequence::_internal_notification() const {
  const ::cn::kylinos::kmre::kmrecore::Notification* p = _impl_.notification_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::Notification&>(
      ::cn::kylinos::kmre::kmrecore::_Notification_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::Notification& EventSequence::notification() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.notification)
  return _internal_notification();
}
inline void EventSequence::unsafe_arena_set_allocated_notification(
    ::cn::kylinos::kmre::kmrecore::Notification* notification) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.notification_);
  }
  _impl_.notification_ = notification;
  if (notification) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.notification)
}
inline ::cn::kylinos::kmre::kmrecore::Notification* EventSequence::release_notification() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cn::kylinos::kmre::kmrecore::Notification* temp = _impl_.notification_;
  _impl_.notification_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::Notification* EventSequence::unsafe_arena_release_notification() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.notification)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cn::kylinos::kmre::kmrecore::Notification* temp = _impl_.notification_;
  _impl_.notification_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::Notification* EventSequence::_internal_mutable_notification() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.notification_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::Notification>(GetArenaForAllocation());
    _impl_.notification_ = p;
  }
  return _impl_.notification_;
}
inline ::cn::kylinos::kmre::kmrecore::Notification* EventSequence::mutable_notification() {
  ::cn::kylinos::kmre::kmrecore::Notification* _msg = _internal_mutable_notification();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.notification)
  return _msg;
}
inline void EventSequence::set_allocated_notification(::cn::kylinos::kmre::kmrecore::Notification* notification) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.notification_;
  }
  if (notification) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notification);
    if (message_arena != submessage_arena) {
      notification = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notification, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.notification_ = notification;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.notification)
}

// optional .cn.kylinos.kmre.kmrecore.EventInfo event_info = 2;
inline bool EventSequence::_internal_has_event_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.event_info_ != nullptr);
  return value;
}
inline bool EventSequence::has_event_info() const {
  return _internal_has_event_info();
}
inline void EventSequence::clear_event_info() {
  if (_impl_.event_info_ != nullptr) _impl_.event_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cn::kylinos::kmre::kmrecore::EventInfo& EventSequence::_internal_event_info() const {
  const ::cn::kylinos::kmre::kmrecore::EventInfo* p = _impl_.event_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::EventInfo&>(
      ::cn::kylinos::kmre::kmrecore::_EventInfo_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::EventInfo& EventSequence::event_info() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.event_info)
  return _internal_event_info();
}
inline void EventSequence::unsafe_arena_set_allocated_event_info(
    ::cn::kylinos::kmre::kmrecore::EventInfo* event_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_info_);
  }
  _impl_.event_info_ = event_info;
  if (event_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.event_info)
}
inline ::cn::kylinos::kmre::kmrecore::EventInfo* EventSequence::release_event_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cn::kylinos::kmre::kmrecore::EventInfo* temp = _impl_.event_info_;
  _impl_.event_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::EventInfo* EventSequence::unsafe_arena_release_event_info() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.event_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cn::kylinos::kmre::kmrecore::EventInfo* temp = _impl_.event_info_;
  _impl_.event_info_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::EventInfo* EventSequence::_internal_mutable_event_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.event_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::EventInfo>(GetArenaForAllocation());
    _impl_.event_info_ = p;
  }
  return _impl_.event_info_;
}
inline ::cn::kylinos::kmre::kmrecore::EventInfo* EventSequence::mutable_event_info() {
  ::cn::kylinos::kmre::kmrecore::EventInfo* _msg = _internal_mutable_event_info();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.event_info)
  return _msg;
}
inline void EventSequence::set_allocated_event_info(::cn::kylinos::kmre::kmrecore::EventInfo* event_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.event_info_;
  }
  if (event_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event_info);
    if (message_arena != submessage_arena) {
      event_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.event_info_ = event_info;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.event_info)
}

// optional .cn.kylinos.kmre.kmrecore.LaunchResult launch_result = 3;
inline bool EventSequence::_internal_has_launch_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.launch_result_ != nullptr);
  return value;
}
inline bool EventSequence::has_launch_result() const {
  return _internal_has_launch_result();
}
inline void EventSequence::clear_launch_result() {
  if (_impl_.launch_result_ != nullptr) _impl_.launch_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::cn::kylinos::kmre::kmrecore::LaunchResult& EventSequence::_internal_launch_result() const {
  const ::cn::kylinos::kmre::kmrecore::LaunchResult* p = _impl_.launch_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::LaunchResult&>(
      ::cn::kylinos::kmre::kmrecore::_LaunchResult_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::LaunchResult& EventSequence::launch_result() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.launch_result)
  return _internal_launch_result();
}
inline void EventSequence::unsafe_arena_set_allocated_launch_result(
    ::cn::kylinos::kmre::kmrecore::LaunchResult* launch_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.launch_result_);
  }
  _impl_.launch_result_ = launch_result;
  if (launch_result) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.launch_result)
}
inline ::cn::kylinos::kmre::kmrecore::LaunchResult* EventSequence::release_launch_result() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cn::kylinos::kmre::kmrecore::LaunchResult* temp = _impl_.launch_result_;
  _impl_.launch_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::LaunchResult* EventSequence::unsafe_arena_release_launch_result() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.launch_result)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::cn::kylinos::kmre::kmrecore::LaunchResult* temp = _impl_.launch_result_;
  _impl_.launch_result_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::LaunchResult* EventSequence::_internal_mutable_launch_result() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.launch_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::LaunchResult>(GetArenaForAllocation());
    _impl_.launch_result_ = p;
  }
  return _impl_.launch_result_;
}
inline ::cn::kylinos::kmre::kmrecore::LaunchResult* EventSequence::mutable_launch_result() {
  ::cn::kylinos::kmre::kmrecore::LaunchResult* _msg = _internal_mutable_launch_result();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.launch_result)
  return _msg;
}
inline void EventSequence::set_allocated_launch_result(::cn::kylinos::kmre::kmrecore::LaunchResult* launch_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.launch_result_;
  }
  if (launch_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(launch_result);
    if (message_arena != submessage_arena) {
      launch_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, launch_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.launch_result_ = launch_result;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.launch_result)
}

// optional .cn.kylinos.kmre.kmrecore.CloseResult close_result = 4;
inline bool EventSequence::_internal_has_close_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.close_result_ != nullptr);
  return value;
}
inline bool EventSequence::has_close_result() const {
  return _internal_has_close_result();
}
inline void EventSequence::clear_close_result() {
  if (_impl_.close_result_ != nullptr) _impl_.close_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::cn::kylinos::kmre::kmrecore::CloseResult& EventSequence::_internal_close_result() const {
  const ::cn::kylinos::kmre::kmrecore::CloseResult* p = _impl_.close_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::CloseResult&>(
      ::cn::kylinos::kmre::kmrecore::_CloseResult_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::CloseResult& EventSequence::close_result() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.close_result)
  return _internal_close_result();
}
inline void EventSequence::unsafe_arena_set_allocated_close_result(
    ::cn::kylinos::kmre::kmrecore::CloseResult* close_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.close_result_);
  }
  _impl_.close_result_ = close_result;
  if (close_result) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.close_result)
}
inline ::cn::kylinos::kmre::kmrecore::CloseResult* EventSequence::release_close_result() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cn::kylinos::kmre::kmrecore::CloseResult* temp = _impl_.close_result_;
  _impl_.close_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::CloseResult* EventSequence::unsafe_arena_release_close_result() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.close_result)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cn::kylinos::kmre::kmrecore::CloseResult* temp = _impl_.close_result_;
  _impl_.close_result_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::CloseResult* EventSequence::_internal_mutable_close_result() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.close_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::CloseResult>(GetArenaForAllocation());
    _impl_.close_result_ = p;
  }
  return _impl_.close_result_;
}
inline ::cn::kylinos::kmre::kmrecore::CloseResult* EventSequence::mutable_close_result() {
  ::cn::kylinos::kmre::kmrecore::CloseResult* _msg = _internal_mutable_close_result();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.close_result)
  return _msg;
}
inline void EventSequence::set_allocated_close_result(::cn::kylinos::kmre::kmrecore::CloseResult* close_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.close_result_;
  }
  if (close_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(close_result);
    if (message_arena != submessage_arena) {
      close_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.close_result_ = close_result;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.close_result)
}

// optional .cn.kylinos.kmre.kmrecore.SetClipboard set_clipboard = 5;
inline bool EventSequence::_internal_has_set_clipboard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.set_clipboard_ != nullptr);
  return value;
}
inline bool EventSequence::has_set_clipboard() const {
  return _internal_has_set_clipboard();
}
inline void EventSequence::clear_set_clipboard() {
  if (_impl_.set_clipboard_ != nullptr) _impl_.set_clipboard_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::cn::kylinos::kmre::kmrecore::SetClipboard& EventSequence::_internal_set_clipboard() const {
  const ::cn::kylinos::kmre::kmrecore::SetClipboard* p = _impl_.set_clipboard_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::SetClipboard&>(
      ::cn::kylinos::kmre::kmrecore::_SetClipboard_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::SetClipboard& EventSequence::set_clipboard() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.set_clipboard)
  return _internal_set_clipboard();
}
inline void EventSequence::unsafe_arena_set_allocated_set_clipboard(
    ::cn::kylinos::kmre::kmrecore::SetClipboard* set_clipboard) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.set_clipboard_);
  }
  _impl_.set_clipboard_ = set_clipboard;
  if (set_clipboard) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.set_clipboard)
}
inline ::cn::kylinos::kmre::kmrecore::SetClipboard* EventSequence::release_set_clipboard() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::cn::kylinos::kmre::kmrecore::SetClipboard* temp = _impl_.set_clipboard_;
  _impl_.set_clipboard_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::SetClipboard* EventSequence::unsafe_arena_release_set_clipboard() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.set_clipboard)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::cn::kylinos::kmre::kmrecore::SetClipboard* temp = _impl_.set_clipboard_;
  _impl_.set_clipboard_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::SetClipboard* EventSequence::_internal_mutable_set_clipboard() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.set_clipboard_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::SetClipboard>(GetArenaForAllocation());
    _impl_.set_clipboard_ = p;
  }
  return _impl_.set_clipboard_;
}
inline ::cn::kylinos::kmre::kmrecore::SetClipboard* EventSequence::mutable_set_clipboard() {
  ::cn::kylinos::kmre::kmrecore::SetClipboard* _msg = _internal_mutable_set_clipboard();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.set_clipboard)
  return _msg;
}
inline void EventSequence::set_allocated_set_clipboard(::cn::kylinos::kmre::kmrecore::SetClipboard* set_clipboard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.set_clipboard_;
  }
  if (set_clipboard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_clipboard);
    if (message_arena != submessage_arena) {
      set_clipboard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_clipboard, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.set_clipboard_ = set_clipboard;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.set_clipboard)
}

// optional .cn.kylinos.kmre.kmrecore.VirtualScreenFocusResult focus_result = 6;
inline bool EventSequence::_internal_has_focus_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.focus_result_ != nullptr);
  return value;
}
inline bool EventSequence::has_focus_result() const {
  return _internal_has_focus_result();
}
inline void EventSequence::clear_focus_result() {
  if (_impl_.focus_result_ != nullptr) _impl_.focus_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult& EventSequence::_internal_focus_result() const {
  const ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* p = _impl_.focus_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult&>(
      ::cn::kylinos::kmre::kmrecore::_VirtualScreenFocusResult_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult& EventSequence::focus_result() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.focus_result)
  return _internal_focus_result();
}
inline void EventSequence::unsafe_arena_set_allocated_focus_result(
    ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* focus_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.focus_result_);
  }
  _impl_.focus_result_ = focus_result;
  if (focus_result) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.focus_result)
}
inline ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* EventSequence::release_focus_result() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* temp = _impl_.focus_result_;
  _impl_.focus_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* EventSequence::unsafe_arena_release_focus_result() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.focus_result)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* temp = _impl_.focus_result_;
  _impl_.focus_result_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* EventSequence::_internal_mutable_focus_result() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.focus_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult>(GetArenaForAllocation());
    _impl_.focus_result_ = p;
  }
  return _impl_.focus_result_;
}
inline ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* EventSequence::mutable_focus_result() {
  ::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* _msg = _internal_mutable_focus_result();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.focus_result)
  return _msg;
}
inline void EventSequence::set_allocated_focus_result(::cn::kylinos::kmre::kmrecore::VirtualScreenFocusResult* focus_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.focus_result_;
  }
  if (focus_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(focus_result);
    if (message_arena != submessage_arena) {
      focus_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, focus_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.focus_result_ = focus_result;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.focus_result)
}

// optional .cn.kylinos.kmre.kmrecore.InputMethodRequest inputmethod_request = 7;
inline bool EventSequence::_internal_has_inputmethod_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inputmethod_request_ != nullptr);
  return value;
}
inline bool EventSequence::has_inputmethod_request() const {
  return _internal_has_inputmethod_request();
}
inline void EventSequence::clear_inputmethod_request() {
  if (_impl_.inputmethod_request_ != nullptr) _impl_.inputmethod_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::cn::kylinos::kmre::kmrecore::InputMethodRequest& EventSequence::_internal_inputmethod_request() const {
  const ::cn::kylinos::kmre::kmrecore::InputMethodRequest* p = _impl_.inputmethod_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::InputMethodRequest&>(
      ::cn::kylinos::kmre::kmrecore::_InputMethodRequest_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::InputMethodRequest& EventSequence::inputmethod_request() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.inputmethod_request)
  return _internal_inputmethod_request();
}
inline void EventSequence::unsafe_arena_set_allocated_inputmethod_request(
    ::cn::kylinos::kmre::kmrecore::InputMethodRequest* inputmethod_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inputmethod_request_);
  }
  _impl_.inputmethod_request_ = inputmethod_request;
  if (inputmethod_request) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.inputmethod_request)
}
inline ::cn::kylinos::kmre::kmrecore::InputMethodRequest* EventSequence::release_inputmethod_request() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::cn::kylinos::kmre::kmrecore::InputMethodRequest* temp = _impl_.inputmethod_request_;
  _impl_.inputmethod_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::InputMethodRequest* EventSequence::unsafe_arena_release_inputmethod_request() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.inputmethod_request)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::cn::kylinos::kmre::kmrecore::InputMethodRequest* temp = _impl_.inputmethod_request_;
  _impl_.inputmethod_request_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::InputMethodRequest* EventSequence::_internal_mutable_inputmethod_request() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.inputmethod_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::InputMethodRequest>(GetArenaForAllocation());
    _impl_.inputmethod_request_ = p;
  }
  return _impl_.inputmethod_request_;
}
inline ::cn::kylinos::kmre::kmrecore::InputMethodRequest* EventSequence::mutable_inputmethod_request() {
  ::cn::kylinos::kmre::kmrecore::InputMethodRequest* _msg = _internal_mutable_inputmethod_request();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.inputmethod_request)
  return _msg;
}
inline void EventSequence::set_allocated_inputmethod_request(::cn::kylinos::kmre::kmrecore::InputMethodRequest* inputmethod_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inputmethod_request_;
  }
  if (inputmethod_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inputmethod_request);
    if (message_arena != submessage_arena) {
      inputmethod_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputmethod_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.inputmethod_request_ = inputmethod_request;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.inputmethod_request)
}

// optional .cn.kylinos.kmre.kmrecore.FilesList files_list = 8;
inline bool EventSequence::_internal_has_files_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.files_list_ != nullptr);
  return value;
}
inline bool EventSequence::has_files_list() const {
  return _internal_has_files_list();
}
inline void EventSequence::clear_files_list() {
  if (_impl_.files_list_ != nullptr) _impl_.files_list_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::cn::kylinos::kmre::kmrecore::FilesList& EventSequence::_internal_files_list() const {
  const ::cn::kylinos::kmre::kmrecore::FilesList* p = _impl_.files_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::FilesList&>(
      ::cn::kylinos::kmre::kmrecore::_FilesList_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::FilesList& EventSequence::files_list() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.files_list)
  return _internal_files_list();
}
inline void EventSequence::unsafe_arena_set_allocated_files_list(
    ::cn::kylinos::kmre::kmrecore::FilesList* files_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.files_list_);
  }
  _impl_.files_list_ = files_list;
  if (files_list) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.files_list)
}
inline ::cn::kylinos::kmre::kmrecore::FilesList* EventSequence::release_files_list() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::cn::kylinos::kmre::kmrecore::FilesList* temp = _impl_.files_list_;
  _impl_.files_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::FilesList* EventSequence::unsafe_arena_release_files_list() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.files_list)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::cn::kylinos::kmre::kmrecore::FilesList* temp = _impl_.files_list_;
  _impl_.files_list_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::FilesList* EventSequence::_internal_mutable_files_list() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.files_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::FilesList>(GetArenaForAllocation());
    _impl_.files_list_ = p;
  }
  return _impl_.files_list_;
}
inline ::cn::kylinos::kmre::kmrecore::FilesList* EventSequence::mutable_files_list() {
  ::cn::kylinos::kmre::kmrecore::FilesList* _msg = _internal_mutable_files_list();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.files_list)
  return _msg;
}
inline void EventSequence::set_allocated_files_list(::cn::kylinos::kmre::kmrecore::FilesList* files_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.files_list_;
  }
  if (files_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(files_list);
    if (message_arena != submessage_arena) {
      files_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, files_list, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.files_list_ = files_list;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.files_list)
}

// optional .cn.kylinos.kmre.kmrecore.MediaPlayStatus mediaplay_status = 9;
inline bool EventSequence::_internal_has_mediaplay_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mediaplay_status_ != nullptr);
  return value;
}
inline bool EventSequence::has_mediaplay_status() const {
  return _internal_has_mediaplay_status();
}
inline void EventSequence::clear_mediaplay_status() {
  if (_impl_.mediaplay_status_ != nullptr) _impl_.mediaplay_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::cn::kylinos::kmre::kmrecore::MediaPlayStatus& EventSequence::_internal_mediaplay_status() const {
  const ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* p = _impl_.mediaplay_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::MediaPlayStatus&>(
      ::cn::kylinos::kmre::kmrecore::_MediaPlayStatus_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::MediaPlayStatus& EventSequence::mediaplay_status() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.mediaplay_status)
  return _internal_mediaplay_status();
}
inline void EventSequence::unsafe_arena_set_allocated_mediaplay_status(
    ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* mediaplay_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mediaplay_status_);
  }
  _impl_.mediaplay_status_ = mediaplay_status;
  if (mediaplay_status) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.mediaplay_status)
}
inline ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* EventSequence::release_mediaplay_status() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* temp = _impl_.mediaplay_status_;
  _impl_.mediaplay_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* EventSequence::unsafe_arena_release_mediaplay_status() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.mediaplay_status)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* temp = _impl_.mediaplay_status_;
  _impl_.mediaplay_status_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* EventSequence::_internal_mutable_mediaplay_status() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.mediaplay_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::MediaPlayStatus>(GetArenaForAllocation());
    _impl_.mediaplay_status_ = p;
  }
  return _impl_.mediaplay_status_;
}
inline ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* EventSequence::mutable_mediaplay_status() {
  ::cn::kylinos::kmre::kmrecore::MediaPlayStatus* _msg = _internal_mutable_mediaplay_status();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.mediaplay_status)
  return _msg;
}
inline void EventSequence::set_allocated_mediaplay_status(::cn::kylinos::kmre::kmrecore::MediaPlayStatus* mediaplay_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mediaplay_status_;
  }
  if (mediaplay_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mediaplay_status);
    if (message_arena != submessage_arena) {
      mediaplay_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mediaplay_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.mediaplay_status_ = mediaplay_status;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.mediaplay_status)
}

// optional .cn.kylinos.kmre.kmrecore.AppMultiplierList app_multipliers = 10;
inline bool EventSequence::_internal_has_app_multipliers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_multipliers_ != nullptr);
  return value;
}
inline bool EventSequence::has_app_multipliers() const {
  return _internal_has_app_multipliers();
}
inline void EventSequence::clear_app_multipliers() {
  if (_impl_.app_multipliers_ != nullptr) _impl_.app_multipliers_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::cn::kylinos::kmre::kmrecore::AppMultiplierList& EventSequence::_internal_app_multipliers() const {
  const ::cn::kylinos::kmre::kmrecore::AppMultiplierList* p = _impl_.app_multipliers_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::AppMultiplierList&>(
      ::cn::kylinos::kmre::kmrecore::_AppMultiplierList_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::AppMultiplierList& EventSequence::app_multipliers() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.app_multipliers)
  return _internal_app_multipliers();
}
inline void EventSequence::unsafe_arena_set_allocated_app_multipliers(
    ::cn::kylinos::kmre::kmrecore::AppMultiplierList* app_multipliers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_multipliers_);
  }
  _impl_.app_multipliers_ = app_multipliers;
  if (app_multipliers) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.app_multipliers)
}
inline ::cn::kylinos::kmre::kmrecore::AppMultiplierList* EventSequence::release_app_multipliers() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::cn::kylinos::kmre::kmrecore::AppMultiplierList* temp = _impl_.app_multipliers_;
  _impl_.app_multipliers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::AppMultiplierList* EventSequence::unsafe_arena_release_app_multipliers() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.app_multipliers)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::cn::kylinos::kmre::kmrecore::AppMultiplierList* temp = _impl_.app_multipliers_;
  _impl_.app_multipliers_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::AppMultiplierList* EventSequence::_internal_mutable_app_multipliers() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.app_multipliers_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::AppMultiplierList>(GetArenaForAllocation());
    _impl_.app_multipliers_ = p;
  }
  return _impl_.app_multipliers_;
}
inline ::cn::kylinos::kmre::kmrecore::AppMultiplierList* EventSequence::mutable_app_multipliers() {
  ::cn::kylinos::kmre::kmrecore::AppMultiplierList* _msg = _internal_mutable_app_multipliers();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.app_multipliers)
  return _msg;
}
inline void EventSequence::set_allocated_app_multipliers(::cn::kylinos::kmre::kmrecore::AppMultiplierList* app_multipliers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_multipliers_;
  }
  if (app_multipliers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_multipliers);
    if (message_arena != submessage_arena) {
      app_multipliers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_multipliers, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.app_multipliers_ = app_multipliers;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.app_multipliers)
}

// optional .cn.kylinos.kmre.kmrecore.ResponseInfo response_info = 11;
inline bool EventSequence::_internal_has_response_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_info_ != nullptr);
  return value;
}
inline bool EventSequence::has_response_info() const {
  return _internal_has_response_info();
}
inline void EventSequence::clear_response_info() {
  if (_impl_.response_info_ != nullptr) _impl_.response_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::cn::kylinos::kmre::kmrecore::ResponseInfo& EventSequence::_internal_response_info() const {
  const ::cn::kylinos::kmre::kmrecore::ResponseInfo* p = _impl_.response_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::ResponseInfo&>(
      ::cn::kylinos::kmre::kmrecore::_ResponseInfo_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::ResponseInfo& EventSequence::response_info() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.response_info)
  return _internal_response_info();
}
inline void EventSequence::unsafe_arena_set_allocated_response_info(
    ::cn::kylinos::kmre::kmrecore::ResponseInfo* response_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_info_);
  }
  _impl_.response_info_ = response_info;
  if (response_info) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.response_info)
}
inline ::cn::kylinos::kmre::kmrecore::ResponseInfo* EventSequence::release_response_info() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::cn::kylinos::kmre::kmrecore::ResponseInfo* temp = _impl_.response_info_;
  _impl_.response_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::ResponseInfo* EventSequence::unsafe_arena_release_response_info() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.response_info)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::cn::kylinos::kmre::kmrecore::ResponseInfo* temp = _impl_.response_info_;
  _impl_.response_info_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::ResponseInfo* EventSequence::_internal_mutable_response_info() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.response_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::ResponseInfo>(GetArenaForAllocation());
    _impl_.response_info_ = p;
  }
  return _impl_.response_info_;
}
inline ::cn::kylinos::kmre::kmrecore::ResponseInfo* EventSequence::mutable_response_info() {
  ::cn::kylinos::kmre::kmrecore::ResponseInfo* _msg = _internal_mutable_response_info();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.response_info)
  return _msg;
}
inline void EventSequence::set_allocated_response_info(::cn::kylinos::kmre::kmrecore::ResponseInfo* response_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_info_;
  }
  if (response_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_info);
    if (message_arena != submessage_arena) {
      response_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.response_info_ = response_info;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.response_info)
}

// optional .cn.kylinos.kmre.kmrecore.MultiplierSwitch multiplier_switch = 12;
inline bool EventSequence::_internal_has_multiplier_switch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.multiplier_switch_ != nullptr);
  return value;
}
inline bool EventSequence::has_multiplier_switch() const {
  return _internal_has_multiplier_switch();
}
inline void EventSequence::clear_multiplier_switch() {
  if (_impl_.multiplier_switch_ != nullptr) _impl_.multiplier_switch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::cn::kylinos::kmre::kmrecore::MultiplierSwitch& EventSequence::_internal_multiplier_switch() const {
  const ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* p = _impl_.multiplier_switch_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::MultiplierSwitch&>(
      ::cn::kylinos::kmre::kmrecore::_MultiplierSwitch_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::MultiplierSwitch& EventSequence::multiplier_switch() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.multiplier_switch)
  return _internal_multiplier_switch();
}
inline void EventSequence::unsafe_arena_set_allocated_multiplier_switch(
    ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* multiplier_switch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiplier_switch_);
  }
  _impl_.multiplier_switch_ = multiplier_switch;
  if (multiplier_switch) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.multiplier_switch)
}
inline ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* EventSequence::release_multiplier_switch() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* temp = _impl_.multiplier_switch_;
  _impl_.multiplier_switch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* EventSequence::unsafe_arena_release_multiplier_switch() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.multiplier_switch)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* temp = _impl_.multiplier_switch_;
  _impl_.multiplier_switch_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* EventSequence::_internal_mutable_multiplier_switch() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.multiplier_switch_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::MultiplierSwitch>(GetArenaForAllocation());
    _impl_.multiplier_switch_ = p;
  }
  return _impl_.multiplier_switch_;
}
inline ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* EventSequence::mutable_multiplier_switch() {
  ::cn::kylinos::kmre::kmrecore::MultiplierSwitch* _msg = _internal_mutable_multiplier_switch();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.multiplier_switch)
  return _msg;
}
inline void EventSequence::set_allocated_multiplier_switch(::cn::kylinos::kmre::kmrecore::MultiplierSwitch* multiplier_switch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.multiplier_switch_;
  }
  if (multiplier_switch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multiplier_switch);
    if (message_arena != submessage_arena) {
      multiplier_switch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiplier_switch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.multiplier_switch_ = multiplier_switch;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.multiplier_switch)
}

// optional .cn.kylinos.kmre.kmrecore.LinkOpen link_open = 13;
inline bool EventSequence::_internal_has_link_open() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.link_open_ != nullptr);
  return value;
}
inline bool EventSequence::has_link_open() const {
  return _internal_has_link_open();
}
inline void EventSequence::clear_link_open() {
  if (_impl_.link_open_ != nullptr) _impl_.link_open_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::cn::kylinos::kmre::kmrecore::LinkOpen& EventSequence::_internal_link_open() const {
  const ::cn::kylinos::kmre::kmrecore::LinkOpen* p = _impl_.link_open_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::LinkOpen&>(
      ::cn::kylinos::kmre::kmrecore::_LinkOpen_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::LinkOpen& EventSequence::link_open() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.link_open)
  return _internal_link_open();
}
inline void EventSequence::unsafe_arena_set_allocated_link_open(
    ::cn::kylinos::kmre::kmrecore::LinkOpen* link_open) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_open_);
  }
  _impl_.link_open_ = link_open;
  if (link_open) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.link_open)
}
inline ::cn::kylinos::kmre::kmrecore::LinkOpen* EventSequence::release_link_open() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::cn::kylinos::kmre::kmrecore::LinkOpen* temp = _impl_.link_open_;
  _impl_.link_open_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::LinkOpen* EventSequence::unsafe_arena_release_link_open() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.link_open)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::cn::kylinos::kmre::kmrecore::LinkOpen* temp = _impl_.link_open_;
  _impl_.link_open_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::LinkOpen* EventSequence::_internal_mutable_link_open() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.link_open_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::LinkOpen>(GetArenaForAllocation());
    _impl_.link_open_ = p;
  }
  return _impl_.link_open_;
}
inline ::cn::kylinos::kmre::kmrecore::LinkOpen* EventSequence::mutable_link_open() {
  ::cn::kylinos::kmre::kmrecore::LinkOpen* _msg = _internal_mutable_link_open();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.link_open)
  return _msg;
}
inline void EventSequence::set_allocated_link_open(::cn::kylinos::kmre::kmrecore::LinkOpen* link_open) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.link_open_;
  }
  if (link_open) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(link_open);
    if (message_arena != submessage_arena) {
      link_open = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_open, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.link_open_ = link_open;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.link_open)
}

// optional .cn.kylinos.kmre.kmrecore.UpdatePackageStatus update_package_status = 14;
inline bool EventSequence::_internal_has_update_package_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_package_status_ != nullptr);
  return value;
}
inline bool EventSequence::has_update_package_status() const {
  return _internal_has_update_package_status();
}
inline void EventSequence::clear_update_package_status() {
  if (_impl_.update_package_status_ != nullptr) _impl_.update_package_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus& EventSequence::_internal_update_package_status() const {
  const ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* p = _impl_.update_package_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus&>(
      ::cn::kylinos::kmre::kmrecore::_UpdatePackageStatus_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus& EventSequence::update_package_status() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.update_package_status)
  return _internal_update_package_status();
}
inline void EventSequence::unsafe_arena_set_allocated_update_package_status(
    ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* update_package_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_package_status_);
  }
  _impl_.update_package_status_ = update_package_status;
  if (update_package_status) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.update_package_status)
}
inline ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* EventSequence::release_update_package_status() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* temp = _impl_.update_package_status_;
  _impl_.update_package_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* EventSequence::unsafe_arena_release_update_package_status() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.update_package_status)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* temp = _impl_.update_package_status_;
  _impl_.update_package_status_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* EventSequence::_internal_mutable_update_package_status() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.update_package_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::UpdatePackageStatus>(GetArenaForAllocation());
    _impl_.update_package_status_ = p;
  }
  return _impl_.update_package_status_;
}
inline ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* EventSequence::mutable_update_package_status() {
  ::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* _msg = _internal_mutable_update_package_status();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.update_package_status)
  return _msg;
}
inline void EventSequence::set_allocated_update_package_status(::cn::kylinos::kmre::kmrecore::UpdatePackageStatus* update_package_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.update_package_status_;
  }
  if (update_package_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_package_status);
    if (message_arena != submessage_arena) {
      update_package_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_package_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.update_package_status_ = update_package_status;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.update_package_status)
}

// optional .cn.kylinos.kmre.kmrecore.SendSystemProp system_prop = 15;
inline bool EventSequence::_internal_has_system_prop() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.system_prop_ != nullptr);
  return value;
}
inline bool EventSequence::has_system_prop() const {
  return _internal_has_system_prop();
}
inline void EventSequence::clear_system_prop() {
  if (_impl_.system_prop_ != nullptr) _impl_.system_prop_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::cn::kylinos::kmre::kmrecore::SendSystemProp& EventSequence::_internal_system_prop() const {
  const ::cn::kylinos::kmre::kmrecore::SendSystemProp* p = _impl_.system_prop_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::SendSystemProp&>(
      ::cn::kylinos::kmre::kmrecore::_SendSystemProp_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::SendSystemProp& EventSequence::system_prop() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.system_prop)
  return _internal_system_prop();
}
inline void EventSequence::unsafe_arena_set_allocated_system_prop(
    ::cn::kylinos::kmre::kmrecore::SendSystemProp* system_prop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_prop_);
  }
  _impl_.system_prop_ = system_prop;
  if (system_prop) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.system_prop)
}
inline ::cn::kylinos::kmre::kmrecore::SendSystemProp* EventSequence::release_system_prop() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::cn::kylinos::kmre::kmrecore::SendSystemProp* temp = _impl_.system_prop_;
  _impl_.system_prop_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::SendSystemProp* EventSequence::unsafe_arena_release_system_prop() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.system_prop)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::cn::kylinos::kmre::kmrecore::SendSystemProp* temp = _impl_.system_prop_;
  _impl_.system_prop_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::SendSystemProp* EventSequence::_internal_mutable_system_prop() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.system_prop_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::SendSystemProp>(GetArenaForAllocation());
    _impl_.system_prop_ = p;
  }
  return _impl_.system_prop_;
}
inline ::cn::kylinos::kmre::kmrecore::SendSystemProp* EventSequence::mutable_system_prop() {
  ::cn::kylinos::kmre::kmrecore::SendSystemProp* _msg = _internal_mutable_system_prop();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.system_prop)
  return _msg;
}
inline void EventSequence::set_allocated_system_prop(::cn::kylinos::kmre::kmrecore::SendSystemProp* system_prop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_prop_;
  }
  if (system_prop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_prop);
    if (message_arena != submessage_arena) {
      system_prop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_prop, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.system_prop_ = system_prop;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.system_prop)
}

// optional .cn.kylinos.kmre.kmrecore.GetInfoList get_info_list = 16;
inline bool EventSequence::_internal_has_get_info_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.get_info_list_ != nullptr);
  return value;
}
inline bool EventSequence::has_get_info_list() const {
  return _internal_has_get_info_list();
}
inline void EventSequence::clear_get_info_list() {
  if (_impl_.get_info_list_ != nullptr) _impl_.get_info_list_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::cn::kylinos::kmre::kmrecore::GetInfoList& EventSequence::_internal_get_info_list() const {
  const ::cn::kylinos::kmre::kmrecore::GetInfoList* p = _impl_.get_info_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::GetInfoList&>(
      ::cn::kylinos::kmre::kmrecore::_GetInfoList_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::GetInfoList& EventSequence::get_info_list() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.get_info_list)
  return _internal_get_info_list();
}
inline void EventSequence::unsafe_arena_set_allocated_get_info_list(
    ::cn::kylinos::kmre::kmrecore::GetInfoList* get_info_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.get_info_list_);
  }
  _impl_.get_info_list_ = get_info_list;
  if (get_info_list) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.get_info_list)
}
inline ::cn::kylinos::kmre::kmrecore::GetInfoList* EventSequence::release_get_info_list() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::cn::kylinos::kmre::kmrecore::GetInfoList* temp = _impl_.get_info_list_;
  _impl_.get_info_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::GetInfoList* EventSequence::unsafe_arena_release_get_info_list() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.get_info_list)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::cn::kylinos::kmre::kmrecore::GetInfoList* temp = _impl_.get_info_list_;
  _impl_.get_info_list_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::GetInfoList* EventSequence::_internal_mutable_get_info_list() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.get_info_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::GetInfoList>(GetArenaForAllocation());
    _impl_.get_info_list_ = p;
  }
  return _impl_.get_info_list_;
}
inline ::cn::kylinos::kmre::kmrecore::GetInfoList* EventSequence::mutable_get_info_list() {
  ::cn::kylinos::kmre::kmrecore::GetInfoList* _msg = _internal_mutable_get_info_list();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.get_info_list)
  return _msg;
}
inline void EventSequence::set_allocated_get_info_list(::cn::kylinos::kmre::kmrecore::GetInfoList* get_info_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.get_info_list_;
  }
  if (get_info_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_info_list);
    if (message_arena != submessage_arena) {
      get_info_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_info_list, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.get_info_list_ = get_info_list;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.get_info_list)
}

// optional .cn.kylinos.kmre.kmrecore.ContainerEnvBootStatus container_env_boot_status = 17;
inline bool EventSequence::_internal_has_container_env_boot_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.container_env_boot_status_ != nullptr);
  return value;
}
inline bool EventSequence::has_container_env_boot_status() const {
  return _internal_has_container_env_boot_status();
}
inline void EventSequence::clear_container_env_boot_status() {
  if (_impl_.container_env_boot_status_ != nullptr) _impl_.container_env_boot_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus& EventSequence::_internal_container_env_boot_status() const {
  const ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* p = _impl_.container_env_boot_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus&>(
      ::cn::kylinos::kmre::kmrecore::_ContainerEnvBootStatus_default_instance_);
}
inline const ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus& EventSequence::container_env_boot_status() const {
  // @@protoc_insertion_point(field_get:cn.kylinos.kmre.kmrecore.EventSequence.container_env_boot_status)
  return _internal_container_env_boot_status();
}
inline void EventSequence::unsafe_arena_set_allocated_container_env_boot_status(
    ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* container_env_boot_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.container_env_boot_status_);
  }
  _impl_.container_env_boot_status_ = container_env_boot_status;
  if (container_env_boot_status) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.container_env_boot_status)
}
inline ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* EventSequence::release_container_env_boot_status() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* temp = _impl_.container_env_boot_status_;
  _impl_.container_env_boot_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* EventSequence::unsafe_arena_release_container_env_boot_status() {
  // @@protoc_insertion_point(field_release:cn.kylinos.kmre.kmrecore.EventSequence.container_env_boot_status)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* temp = _impl_.container_env_boot_status_;
  _impl_.container_env_boot_status_ = nullptr;
  return temp;
}
inline ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* EventSequence::_internal_mutable_container_env_boot_status() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.container_env_boot_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus>(GetArenaForAllocation());
    _impl_.container_env_boot_status_ = p;
  }
  return _impl_.container_env_boot_status_;
}
inline ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* EventSequence::mutable_container_env_boot_status() {
  ::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* _msg = _internal_mutable_container_env_boot_status();
  // @@protoc_insertion_point(field_mutable:cn.kylinos.kmre.kmrecore.EventSequence.container_env_boot_status)
  return _msg;
}
inline void EventSequence::set_allocated_container_env_boot_status(::cn::kylinos::kmre::kmrecore::ContainerEnvBootStatus* container_env_boot_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.container_env_boot_status_;
  }
  if (container_env_boot_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(container_env_boot_status);
    if (message_arena != submessage_arena) {
      container_env_boot_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container_env_boot_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.container_env_boot_status_ = container_env_boot_status;
  // @@protoc_insertion_point(field_set_allocated:cn.kylinos.kmre.kmrecore.EventSequence.container_env_boot_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kmrecore
}  // namespace kmre
}  // namespace kylinos
}  // namespace cn

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_KmreCore_2eproto
